# 7.1 API 요청

프론트엔드에서 데이터를 가져올 때 보통 서버(백엔드)와 통신함.

예를 들어, 장바구니 개수를 보여주려면 서버에 "내 장바구니 정보 좀 줘!" 하고 요청해야 함.  
이걸 **API 요청**이라고 부름.

---

## 1. fetch로 API 요청하기

자바스크립트 기본 기능인 **fetch 함수**를 쓰면 서버에 요청 가능.

```ts
useEffect(() => {
  fetch("카트정보 URL").then(({ cartItem }) => {
    setCartCount(cartItem.length);
  });
}, []);
```

하지만 fetch를 컴포넌트 안에 막 써버리면,

- 나중에 API 주소가 바뀌거나
- 새로운 규칙(예: 헤더 추가)이 생기면

모든 컴포넌트 안 코드를 다 고쳐야 해서 힘들어짐.

---

## 2. 서비스 레이어 분리

그래서 보통 API 요청 코드를 따로 파일로 분리함.  
컴포넌트는 "서비스 함수"만 불러오면 되고, 실제 요청은 서비스 함수가 처리 → 유지보수가 훨씬 쉬워짐.

---

## 3. Axios 사용

fetch는 단순하지만 불편한 점이 많음.  
그래서 보통 **Axios**라는 라이브러리를 씀.

- fetch: 기본 제공, 기능이 단순 → 직접 많이 구현해야 함
- Axios: 설치 필요, 편리한 기능 제공 (헤더, 응답 처리, 에러 처리 등)
- Axios는 여러 서버(API 주소)가 있을 때 각각 다른 설정을 할 수 있도록 "인스턴스"를 만들어둠

```ts
const apiRequester = axios.create({ baseURL: "https://api.baemin.com" });
const orderApiRequester = axios.create({ baseURL: "https://api.order.com" });
```

---

## 4. Axios Interceptors

인터셉터(interceptor)는 "요청이나 응답을 가로채서 가공"하는 기능임.

- 예시) 요청 보낼 때마다 자동으로 `user-token` 같은 헤더를 붙여줌

```ts
apiRequester.interceptors.request.use((config) => {
  config.headers["user"] = getUserToken();
  return config;
});
```

이렇게 하면 컴포넌트에서 매번 헤더를 붙이지 않아도 됨.

---

## 5. API 응답 타입 지정

TypeScript에서는 서버 응답을 타입으로 정의해두면 안전함.

```ts
interface Response<T> {
  data: T;
  status: string;
  errorCode?: string;
}
```

→ "서버가 어떤 모양으로 응답할지"를 코드 차원에서 보장 가능.

---

## 6. 뷰모델(ViewModel)

서버 응답이 자주 바뀌면, 그 응답을 그대로 쓰면 컴포넌트가 다 망가짐.  
그래서 응답을 **내가 원하는 모양으로 바꿔주는 클래스**(뷰모델)를 만들어 둠.

```ts
class JobList {
  readonly totalItemCount: number;
  readonly items: JobListItemResponse[];

  constructor({ jobItems }: JobListResponse) {
    this.totalItemCount = jobItems.length;
    this.items = jobItems;
  }
}
```

→ 서버 응답이 바뀌더라도 뷰모델만 고치면 됨.

---

# 7.2 API 상태 관리하기

데이터 요청에는 `"로딩 중"`, `"성공"`, `"에러"` 같은 상태가 있음.

이걸 관리하는 방법은 크게 **2가지**.

- 상태관리 라이브러리 (예: Redux, Zustand) → API 요청 결과를 전역 상태로 저장
- 데이터 요청 전용 훅 라이브러리 (예: react-query, SWR) → 요청 + 캐싱 + 에러 처리까지 편리하게 제공

### react-query 예시

```ts
const useFetchJobList = () => {
  return useQuery(["fetchJobList"], async () => {
    const response = await JobService.fetchJobList();
    return new JobList(response);
  });
};
```

→ 자동으로 캐싱, 로딩 상태, 에러 상태 등을 관리해줌.

---

## 정리

- fetch는 기본 제공이지만 불편 → 보통 Axios 사용
- API 코드는 컴포넌트 안이 아니라 "서비스 레이어"로 분리
- Axios Interceptors로 공통 로직(헤더, 에러 처리) 관리
- 응답 타입을 지정해서 안전하게 코딩
- 서버 응답이 자주 바뀌면 뷰모델로 감싸서 안정성 확보
- 상태 관리는 Redux 같은 전역 관리 or react-query 같은 훅 라이브러리 활용

---

# 7.3 API 에러 핸들링

비동기 API 요청을 하면 401/404/500, CORS 에러 등 여러 종류의 에러가 생김.  
에러를 타입으로 명확히 표현하고, 공통 처리 로직을 만들어두면 유지보수가 쉬워지고 사용자에게 더 정확한 메시지를 보여줄 수 있음.

---

## 1. 타입 가드로 “이게 서버 에러인지” 판별하기

Axios는 `axios.isAxiosError(error)` 라는 타입 가드를 제공함.  
서버가 내려주는 에러 응답 모양을 타입으로 정의해 두고, 그 타입의 AxiosError인지 체크 가능.

```ts
export interface ErrorResponse {
  status: string;
  serverDateTime: string;
  errorCode: string;
  errorMessage: string;
}

function isServerError(error: unknown): error is AxiosError<ErrorResponse> {
  return axios.isAxiosError(error);
}
```

---

## 2. 에러 종류를 클래스로 나누기

- UnauthorizedError → 로그인 만료(401)
- NetworkError → 네트워크 문제
- OrderHttpError → 서버 에러

→ 각각 클래스화하면 처리 방식이 분리되고 가독성도 좋아짐.

---

## 3. 인터셉터로 “공통 에러 처리”

Axios 응답 인터셉터에서 로그인 만료(401) 같은 공통 로직을 한 곳에 모아둘 수 있음.

---

## 4. 에러 바운더리(React)로 “UI 안전망” 만들기

컴포넌트에서 처리 못 한 예외가 터져도 앱 전체가 하얀 화면이 되는 걸 막아줌.  
→ fallback UI 제공, 로깅 가능.

---

## 5. react-query로 “상태 + 에러” 함께 다루기

`react-query`는 로딩/성공/에러 상태를 자동으로 관리해줘서 편리함.

---

## 6. 200 OK인데 비즈니스 에러인 경우

가끔 서버가 HTTP 200을 주면서, 본문엔 비즈니스 에러 코드를 담을 수 있음.  
이럴 땐 응답 인터셉터에서 상태를 검사해 에러로 변환하면 호출부에서 일관되게 다룰 수 있음.

---

# 7.4 API 모킹이란?

프론트엔드 개발 중 서버가 아직 준비되지 않았을 때, 가짜 데이터(목업, Mock)를 만들어 개발을 이어가는 것.

---

## 1. JSON 파일 불러오기

간단하게 JSON 파일을 데이터처럼 사용.

- 장점: 설정 없이 바로 사용 가능
- 단점: 나중에 실제 서버 API로 바꿔야 함

---

## 2. NextApiHandler 활용하기

Next.js라면 NextApiHandler로 간단한 API 서버 흉내 가능.

---

## 3. 조건 분기해서 목업/실제 API 나누기

개발 시엔 목업, 서버 준비되면 실제 API → 조건문으로 분리.

---

## 4. axios-mock-adapter 사용하기

Axios 요청을 가로채서 원하는 응답이나 에러를 흉내낼 수 있음.  
네트워크 에러까지 시뮬레이션 가능.

---

## 5. 목업 사용 여부 제어하기

실제 운영 서버에선 목업 필요 없음 → 보통 환경 변수로 제어.

---

## 정리

- JSON 파일: 가장 간단, 빠른 목업
- NextApiHandler: Next.js에서 서버처럼 흉내
- 조건 분기: 상황에 따라 목업/실제 API 나누기
- axios-mock-adapter: 응답/에러 상황 마음대로 제어
- 환경 변수 플래그: 로컬에서만 목업 켜고, 운영에선 끔
