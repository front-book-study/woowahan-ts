# API 요청 패턴 및 데이터 관리 가이드

## 7.1 API 요청

### API Builder 패턴


## API 응답 타입 지정하기

### 타입 안전성 확보

```tsx
import { AxiosPromise } from "axios";

export interface Response<T> {
  data: T;
  status: string;
  serverDateTime: string;
  errorCode?: string;
  errorMessage?: string;
}

const fetchCart = (): AxiosPromise<Response<FetchCartResponse>> =>
  apiRequester.get<Response<FetchCartResponse>>("cart");

const postCart = (
  postCartRequest: PostCartRequest
): AxiosPromise<Response<PostCartResponse>> =>
  apiRequester.post<Response<PostCartResponse>>("cart", postCartRequest);
```


```tsx
const updateCart = (...): AxiosPromise<Response<FetchCartResponse>> =>
  apiRequester.get("cart");
```

## 뷰모델(ViewModel) 패턴

### 뷰모델의 역할

뷰모델은 API 변경이 UI 컴포넌트 코드까지 직접 전파되지 않도록 하는 **방화벽(Firewall)** 또는 **어댑터(Adapter)** 역할을 수행합니다.

### API 변경 시 영향도 비교

API 응답이 `{ jobItems: [...] }`에서 `{ jobs: [...], total: 10 }`으로 변경된 상황:

#### 뷰모델이 없는 경우
```tsx
// 여러 컴포넌트에서 API 응답을 직접 사용
// 컴포넌트_A.tsx
props.jobItems.map(...)

// 컴포넌트_B.tsx
<div>총 {props.jobItems.length}개</div>

// 컴포넌트_C.tsx
if (props.jobItems.length > 0) ...
```

**문제점**: A, B, C 모든 컴포넌트에서 런타임 에러 발생, 관련된 모든 파일을 찾아서 수정 필요

#### 뷰모델이 있는 경우
```tsx
class JobList {
  constructor(data) {
    // API 변경 시 이 부분만 수정하면 됨
    this.jobs = data.jobs; // 기존: data.jobItems
    this.total = data.total; // 새로 추가
  }
}
```

**장점**: `new JobList(data)` 부분만 수정하면 되고, UI 컴포넌트들은 수정 불필요

### 런타임 응답 타입 검증

**문제**: 응답 값의 타입이 변경되어 잘못된 타입이 전달되면 TypeScript는 런타임에서 발생하는 오류를 찾아낼 수 없음

**해결**: 런타임 타입검사 라이브러리 사용 (예: Zod, Yup, Joi 등)

## API 에러 핸들링

### 주요 에러 처리 방법

1. **에러 서브클래싱**: 커스텀 에러 클래스 생성으로 에러 유형별 처리
2. **인터셉터**: axios interceptor를 통한 전역 에러 처리
3. **에러 바운더리**: React Error Boundary로 컴포넌트 레벨 에러 처리
4. **그 외 처리**: 개별 API 호출별 에러 처리

## 데이터 패칭 라이브러리

### 도입 배경

**문제 인식**: 
- 상태 관리 목적의 상당 부분이 비동기 통신을 위함
- 서버에서 가져온 데이터 관리 용도로 클라이언트 상태를 관리하는 MobX, Redux를 사용하는 게 맞는가?

**해결책**: TanStack Query 도입

### TanStack Query vs SWR 선택 기준

**TanStack Query 선택 이유**:
- 직관적 인터페이스
- 다양한 기능 (캐싱, 동기화, 백그라운드 업데이트 등)
- 풍부한 에코시스템과 커뮤니티 지원

### 장점
- 서버 상태와 클라이언트 상태의 명확한 분리
- 자동 캐싱 및 동기화
- 로딩, 에러 상태 자동 관리
- 백그라운드에서 데이터 재검증




