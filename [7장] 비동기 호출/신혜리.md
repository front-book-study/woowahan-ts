## 7.1 ] API 요청

---

### **1. fetch로 API 요청하기**

- api url, timeout 설정, custom header이 각 api 요청마다 하드코딩 되는 형태
- 새로운 api 요청 추가될때마다 새롭게 설정해줘야함
- 변경 요구에 취약

### **2. 서비스 레이어로 분리하기**

- 컴포넌트 영역에서 분리되어 api 요청 (비동기 호출 코드) 을 서비스 레이어에서 핸들링.
- BUT, fetch 함수를 분리하는 것만으로 해결 X
- 각 api 요청마다 timeout, api url 넣는 것은 동일하기 때문.

### **3. Axios 활용하기**

- fetch : 별도의 라이브러리가 필요없이 내장됨 → import / export 불필요
- axios : fetch에서 지원하지 않는 기능들을 지원.
  - baseUrl, timeout 설정해서 인스턴스 생성 가능 → baseUrl이 2개면 별도의 인스턴스로 분리가능

### **4. Axios 인터셉터 사용하기**

https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FbOdZQS%2FbtsIUVWyeiI%2FAAAAAAAAAAAAAAAAAAAAAFWRVLtMPhX6ESaaD-3Hb63Rgh_-21aQ9QQ-ExKj9cxz%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1759244399%26allow_ip%3D%26allow_referer%3D%26signature%3D%252BLYeanD7L7zuul6DVAeapsC3rZI%253D

- interceptor을 이용해서 요청을 보내기전, 응답을 받은 후를 커스터마이징할 수 있음
- request interceptor을 이용해서 request 별로 다른 헤더를 설정해줄 수 있음
- response interceptor을 이용해서 response 의 에러를 한번에 처리할 수 있음

- 요청 옵션에 따라 다른 인터셉터를 만들기 위해 **`Builder Pattern`**을 추가하여 APIBuilder 같은 클래스 형태로 구성하기도 한다.
  - 단점 : 보일러 플레이트가 많음.
  - 장점 : 인터셉터를 유동적으로 설정할 수 있음.

### 5. API 응답 타입 지정하기

- Response 타입은 apiRequester가 모르게 관리되어야함.
  - update, create 같이 응답이 없을 수 있는 api의 타입을 지정하기 어렵기 때문.
- 어떤 응답값이 올지 모르는 경우에는 unknown 타입을 사용하기

### **6. 뷰 모델(View Model) 사용하기**

- 뷰 모델을 사용해 API 변경에 따른 범위를 한정해줘야함. → API 응답이 바뀌어도 UI가 깨지지 않음
- 그러나 뷰 모델 방식에서도 문제가 발생 → API 20개 : 뷰 모델이 20개 이상 추가될 수도 있다는 뜻
- 때문에 API 응답의 변경에 따라 클라이언트 코드를 수정하는 비용을 줄이면서도 도메인의 일관성을 지킬 수 있는 절충안을 찾아야 함.

### **7. Superstruct를 사용해 런타임에서 응답 타임 검증하기**

- 인터페이스 정의와 자바스크립트 런타임의 데이터의 유효성 검사를 해줌. (zod 같은 역할)

### **8. 실제 API 응답 시의 Superstruct 활용 사례**

- 타입스크립트는 컴파일 타임에만 검사를 해줌. 실제 api 데이터는 어떻게 올지 모르기 때문에 런타임 검사도 필요함.
- assert를 이용해서 검증하고 있음

```tsx
import { assert } from 'superstruct';

function isListItem(listItems: ListItem[]) {
  listItems.forEach(listItem => assert(listItem, ListItem));
}
```

## 7.2 ] API 상태 관리하기

---

### **1. 상태 라이브러리에서 호출하기**

- Redux는 비동기 상태가 아닌 전역 상태를 위해 만들어진 라이브러리
  - 비동기 상태관리 위해서는 미들웨어가 필요 (redux-saga)
- 보일러플레이트 코드가 많아진다. → 관리가 어려움
- 모든 상태 관리 라이브러리에서 비동기 처리 함수를 호출하기 위해 액션이 추가될 때마다 관련된 스토어나 상태가 계속 늘어남.
  → 전역 상태 관리자가 모든 비동기 상태에 접근하고 변경가능
  → 의도치 않은 상태 변경 발생 가능성

### **2. 훅으로 호출하기**

- react-query / useSwr : 상태 변경 라이브러리보다 간단
- 캐시를 사용하여 비동기 함수를 호출
- 상태 관리 라이브러리에서 발생했던 의도치 않은 상태 변경을 방지하는 데 도움이 됨

## 7.3 ] API 에러 핸들링

---

### **1. 타입 가드 활용하기**

- axios에서는 isAxiosError라는 타입 가드 제공
- 타입 명제를 이용해서 사용자 정의 타입 가드 정의 가능

```tsx
function isServerError(error: unknown): error is AxiosError<ErrorResponse> {
  return axios.isAxiosError(error);
}
```

### **2. 에러 서브클래싱하기**

- 서브클래싱 : 기존 클래스를 확장하여 새로운 클래스를 만드는 과정
- 인증 정보, 네트워크, 타임아웃 같은 에러들을 그룹핑해서 로직 처리할 수 있음
  - 에러 인스턴스가 무엇인지에 따라 에러 처리 방식을 다르게 구현할 수 있기 때문
  -

### **3. 인터셉터를 활용한 에러 처리**

- HTTP 에러에 일관된 로직을 적용가능

### 4. **에러 바운더리를 활용한 에러 처리**

- 리액트에서 제공하는 에러처리하는 리액트 컴포넌트
- 리액트 컴포넌트 트리 하위에 있는 컴포넌트에서 발생한 에러를 캐치하고, 해당 에러를 가장 가까운 부모 에러 바운더리에서 처리함.
- 에러가 발생한 컴포넌트 대신에 에러 처리를 하거나 예상치 못한 에러를 공통 처리할 때 사용할 수 있음

### **5. 상태 관리 라이브러리에서의 에러 처리**

- 리덕스 사용한 예제…

### **6. react-query를 활용한 에러 처리**

- react-query / swr : 요청에 대한 상태를 변환 → isLoading, isError, error

```tsx
// react-query 사용 예시
const JobComponent: React.FC = () => {
  const { isError, error, isLoading, data } = useFetchJobList();
  if (isError) {
    return (
      <div>{`${error.message}가 발생했습니다. 나중에 다시 시도해주세요.`}</div>
    );
  }
  if (isLoading) {
    return <div>로딩 중입니다.</div>;
  }
  return (
    <>
      {data.map(job => (
        <JobItem key={job.id} job={job} />
      ))}
    </>
  );
};
```

### **7. 그 밖의 에러 처리**

- api 응답: 주로 http code 반환
- BUT 비즈로직 유효성 검증하기 위해서 커스텀 에러를 200과 함께 전달하기도 함.
- 이때, 에러를 던져서 400,500대와 함께 에러 처리가능

## 7.4 ] API 모킹

---

가짜 서버(Mock Server)의 경우 모든 예외 사항을 처리하는 것은 쉽지 않고, 매번 테스트를 위해 구현을 반복하는 것은 번거롭다.

이럴 때 모킹(Mocking)이라는 방법을 활용할 수 있다.

모킹은 가짜 모듈을 활용하는 것으로, 앞서 제시한 상황에서 유연하게 대처할 수 있다.

또한 dev 서버가 불안정하거나 AWS 등에 문제가 생겼을 때와 같은 서버 상태에 문제가 발생한 경우에도 서버의 영향을 받지 않고 프론트엔드 개발을 할 수 있다.

이외에도 이슈가 생겼을 때 charles 등의 도구를 활용하면 응답 값을 그대로 복사하여 이슈 발생 상황을 재현하는 데 도움이 된다.

### **1. JSON 파일 불러오기**

- 간단한 조회만 필요한 경우 사용
- 별도의 환경 설정이 필요하지 않아 쉽게 구현 가능.
- 사용자의 인터렉션 없이 빠르게 목업을 구축할 때 유용
- BUT 실제 API로 요청하는 것이 아니기 때문에 추후에 요청 경로 바꿔줘야함

### **2. NextApiHandler 활용하기**

- Next.js를 사용하면 가능
- 단순한 파일을 불러오는 것과 다르게 중간 과정에 응답 처리 로직을 추가할 수 있음

```tsx
// api/mock/brand
import { NextApiHandler } from 'next';

const BRANDS: Brand[] = [
  {
    id: 1,
    label: '배민스토어',
  },
  {
    id: 2,
    label: '비마트',
  },
];

const handler: NextApiHandler = (req, res) => {
  // request 유효성 검증
  res.json(BRANDS);
};

export default handler;
```

### **3. API 요청 핸들러에 분기 추가하기**

- API 요청을 훅 또는 별도 함수로 선언해준 다음 조건에 따라 목업 함수를 내보내거나 실제 요청 함수를 내보낼 수 있음
- 유지보수할 때 목업 함수를 사용할 수 있음.
- BUT 모든 API 요청 함수에 if 분기문을 추가해야하는 번거로움 있음

### **4. axios-mock-adapter로 모킹하기**

- 서비스 함수에 분기처리 하지 않고 싶으면 → 라이브러리를 사용
- axios-mock-adapter : Axios 요청을 가로챔 → 요청에 대한 응답 값을 대신 반환
- 단순히 응답 바디만 모킹 + 상태 코드, 응답 지연 시간 등을 추가 설정 가능
- GET 뿐만 아니라 POST, PUT, DELETE 등 다른 HTTP 메서드에 대한 목업 가능.

### **5. 목업 사용 여부 제어하기**

- 플래그를 사용하여 목업으로 개발할 때와 개발하지 않을 때를구분.
  - 로컬 개발 : 주로 목업을 사용
  - dev 서버 환경 : dev 서버를 바라봄
- 결과적으로 프론트엔드와 서버를 독립시킬 수 있음
  - dev 서버에 문제가 생기더라도 로컬에서 진행되는 프론트엔드 개발에는 영향을 주지 않음
- 목업을 사용할 때 네트워크 요청을 확인하고 싶을 때는 네트워크에 보낸 요청을 변경해주는 Cypress 같은 도구의 웹푹을 사용하면 됨.
