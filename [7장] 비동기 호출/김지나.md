## 7.1 API 요청
### 7.1.1 fetch로 API요청하기
fetch 함수를 사용하면 외부 데이터 베이스에 접근하여 데이터를 가져올 수 있다. 하지만 컴포넌트 내부에서 매번 비동기 호출 코드를 여러곳에서 사용한다면 URL 변경이나 새로운 API 요청 정책이 추가될 때마다 비동기 호출 코드를 수정해야하는 번거로움이 생긴다. 
=> 비동기 호출 코드는 뷰 영역에서 분리되어 서비스 레이어에서 처리되어야 한다. 

### 7.1.2 서비스 레이어로 분리하기
단순히 fetch함수를 분리하는 것만으로는 API요청 정책이 추가되는 것을 해결하기 어렵다. 또한 쿼리 매개변수나 커스텀 헤더 추가, 쿠키를 읽어 토큰을 넣는 등의 다양한 API정책을 구현하기는 번거롭다. 

### 7.1.3 Axios 활용하기
fetch를 직접 쓰는 대신 Axios 라이브러리를 사용할 수 있다. 

- 기존의 BASE URL과는 다른 새로운 URL로 요청해야하는 상황이 생길 때 각 서버의 기본 URL을 호출하도록 API 요청을 처리하는 인스턴스를 따로 구성해야한다.

### 7.1.4 Axios 인터셉터 사용하기
- 각각의 requester는 서로 다른 역할을 담당하는 다른 서버이기 때문에 requester별로 커스텀 헤더를 설정해줘야하는 로직이 필요할 수 있다.
- 그럴 경우 axios에서 제공하는 interceptors기능을 사용하여 requester에 따라 비동기 호출 내용에 추가해서 처리할 수 있다. 
- 요청 옵션에 따라 다른 인터셉터를 만들기 위해 빌더 패턴을 추가하여 APIBuilder와 같은 클래스 형태로 구성하기도 한다. 

> 빌더 패턴 : 객체 생성을 더 편리하고 가독성 있게 만들기 위한 디자인 패턴 중 하나. 주로 복잡한 객체의 생성을 단순화하고, 객체 생성 과정을 분리하여 객체를 조립하는 방법을 제공

### 7.1.5 API 응답 타입 지정하기
같은 서버에서 오는 응답의 형태는 대체로 통일되어 있어서 하나의 Response 타입으로 묶일 수 있다.

```
interface Response<T> {
  data: T;
  status: string;
  serverDateTime: string;
  errorCode?: string;
  errorMessage?: string;
}

const fetchCart = (): AxiosPromise<Response<FetchCartResponse>> =>
  apiRequester.get < Response < FetchCartResponse >> "cart";

const postCart = (
  postCartRequest: PostCartRequest
): AxiosPromise<Response<PostCartResponse>> =>
  apiRequester.post<Response<PostCartResponse>>("cart", postCartRequest);
  ```
  
  위렇게 서버에서 오는 응답을 통일해줄 때는 주의할 점이 있다. 
  - response 타입을 apiRequester 내에서 처리하고 싶은 생각이 들 수 있겠지만 UPDATE나 CREATE같은 응답이 없을 수 있는 API를 처리하기 까다로로워 진다.
  -> 따라서 Response 타입은 apiRequester가 모르게 관리되어야 한다.

```
const updateCart = (updateCartRequest): AxiosPromise<Response<FetchCartResponse>> =>
apiRequester.get("cart");
```

