# 상태

### 어떤 값을 상태로 정의할 때 2가지 고려사항

1. 시간이 지나도 변하지 않는다면 상태가 아니다.
2. 파생된 값은 상태가 아니다.

### 객체 참조 동일성 유지 방법 2가지

1. useState의 초기값만 지정
    1. 지연 초기화
    
    ```tsx
    const [sotre] = useState(()=> new Store());
    ```
    
2. useRef (✅ 권장)
    1. 리엑트 공식 문서
        
        > "useRef는 DOM 노드를 참조할 때만 사용하는 것이 아닙니다. ref 객체는 current 프로퍼티가 변경 가능하고 어떤 값이든 보관할 수 있는 일반적인 컨테이너입니다.”
        > 
    
    ```tsx
    const store = useRef<Store>(null)
    ```
    

메모제이션도 가능하지만 권장되지 않음 

⇒ 메모제이션은 성능향상을 위한 용도로만 사용

객체 참조 동일성이 필요한 경우:

1. **비싼 초기화 비용** - 한 번만 생성하고 재사용
2. **외부 리소스 관리** - WebSocket, Worker, 라이브러리 인스턴스
3. **이벤트/구독 시스템** - 정확한 등록/해제를 위해
4. **캐시/메모이제이션** - 데이터 누적이 필요한 경우
5. **상태 관리** - 컴포넌트 생명주기와 독립적인 상태
6. **리소스 정리** - cleanup 시 정확한 인스턴스 참조 필요

**공통점**: 모두 "**상태가 아닌 도구나 리소스**"를 다룰 때 필요

## useState vs useReducer

- 다수의 하위 필드를 포함하고 있는 복잡한 상태 로직
- 다음 상태가 이전 상태에 의존적일 때

## 전역 상태 관리

### Context API
