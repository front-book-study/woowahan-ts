# 2.1 ] 타입이란

---

- 정적 타입과 동적 타입

  - 정적 타입시스템 : 모든 변수 타입은 컴파일 타임에 결정 (ex. C, 자바, 타입스크립트)
  - 동적 타입시스템 : 모든 변수 타입은 런 타임에 결정 (ex. 파이썬, 자바스크립트)

- 강타입과 약타입

  - 강타입 : 서로 다른 타입을 갖는 값끼리 연산 시도하면 에러 발생 (ex. 파이썬, 루비, 자바스크립트)
  - 약타입 : 서로 다른 타입을 갖는 값끼리 연산 시도시 컴파일러 / 인터프리터가 내부적으로 판단해서 값의 타입을 변환하여 연산 수행 (ex. c++, 자바, 자바스크립트)

- 컴파일 방식
  - 사람이 이해할 수 있는 언어 (자바, c#) → 컴퓨터로 이해할 수 있는 기계어 (바이너리 코드) 로 바꾸주는 과정
  - 서로 다른 수준간이의 코드 변환 의미
  - 타입스크립트 ⇒ 자바스크립트 컴파일은 아직도 사람만이 이해할 수 있는 언어
  - 타입스크립트의 타입 레이어를 걷어내는 과정

# 2.2 ] 타입스크립트의 타입 시스템

---

- 타입 애너테이션 방식 : 변수, 상수, 함수의 인자, 함수의 반환 값에 타입을 명시적으로 선언해서 어떤 타입 값이 저장될 것인지를 컴파일러에 직접 알려주는 문법
  - 자바, c# : 변수 앞에 데이터 타입 작성
  - 타입스크립트 : 변수 이름 뒤에 데이터 타입 명시
- 구조적 타이핑 :
  - 자바 : 명목적 타입 언어. 구조보다는 이름으로 타입 구분. 같은 구조더라도 이름이 다르면 다른 타입으로 인식
  - 타입스립트 : 구조로 타입을 구분하는 구조적 타이핑.
- 구조적 서브타이핑 : 객체가 가지고 있는 속성을 바탕으로 타입 구분
  - 집합의 부분집합이라도 같은 타입으로 호환가능.
- 자바스크립트를 닮은 타입스크립트
  - 자바스크립트는 덕타이핑 기반 → 런타임에 타입 검사 (동적 타이핑)
  - 타입스크립트는 구조적 타이핑 → 컴파일 타입에 타입 검사 (정적타이핑)
  - 구조적 타이핑을 사용함으로써 명시적 타이핑 보다 유연한 타이핑 가능
  - 쉬운 사용성, 안정성에 균형이 맞춰짐.
  - 명시적 타이핑은 안정성을 추구.
- 구조적 타이핑의 결과

  - 구조적 타이핑의 한계로 예상치 못한 결과가 나오는 경우가 있음
  - 한계 극복을 위해 명목적 타이핑을 일부 차용 ⇒ ex. 유니온

- 타입스크립트의 점진적 타입 확인
  - 컴파일 타임에 타입 검사하지만 타입 선업 생략 허용
  - 생략된 타입은 동적으로 검사 수행 → 암시적 타입 변환 발생 any
  - 마이그레이션할 때 유용. 일반 JS도 TS에서 돌아가기 때문.
  - 타입 안정성이 높지 않기 떄문에 런타임에서 에러 발생하기도 함.
  - 팁) any 사용을 막기 위해서 noImplicitAny: true 로 설정하면 됨!
- 자바스크립트 슈퍼셋으로서의 타입스크립트
  - 자바스크립트 ⇒ 타입스립트 (O)
  - 타입스크립트 ⇒ 자바스크립트 (X) : 자바스크립트는 타입이 없기 떄문에.
- 타입을 확인하는 방법
  - `typeof`
    - **값의 typeof**
      - 런타임의 typeof 연산자
      - 자바스크립트의 typeof 연산자와 동일하게 동작
      - boolean, null, undefined, number, bigInt, string, symbol, function, object 를 문자열로 반환.
      - 주의할점 : 자바스크립트의 클래스는 함수이기 때문에 Class의 typeof = ‘function’ 이 됨.
    - **타입의 typeof**
      - 타입스크립트의 타입을 반환
      - 클래스는 생성자 함수인 경우 typeof Class가 반환, 인스턴스는 Class가 반환.
  - `instanceof`
    - 프로토타입 체이닝 어딘가에 생성자의 프로토타입 속성이 존재하는지 판단할 수 있음.

# 2.3 ] 원시 타입

---

- boolean : true / false
  - truthy, falsy value (false제외) 는 boolean을 반환하지 않음.
  - falsy value = 0 (number) / -0 (number) / 0n (bigInt) / null (null) / undefined (undefined) / NaN (number) / ‘’ (string)
- undefined : 초기값이 설정되어 있지 않을때 주로 할당되는 값
- null : 빈값을 할당할때 사용. 명시적 의도적으로 값이 비어있음을 나타냄.
- number : 숫자에 해당하는 모든 값을 할당할 수 있음.
  - java, c 와 달리 정수, 부동소수점수를 구분하지 않음.
  - NaN (Not a Number), Infinity 도 할당 가능.
- bigInt : Number.MAX_SAFE_INTEGER(2^53-1) 을 넘어가는 값을 할당할 수 있음.
  - bigInt와 number는 다른 타입
  - ES2020에서 도입된 새로운 데이터 타입
- string : 문자열 (빈문자열, 템플릿 리터럴 포함) 을 할당할 수 있음.
- symbol : Symbol 함수를 이용해서 유니크한 값을 할당할 수 있음.
  - ES2015에서 도입된 새로운 데이터 타입

# 2.4 ] 객체 타입

---

- object : 객체, 배열, 정규표현식, 함수, 클래스 모두 object 타입과 호한
  - 광범위한 타입으로 가급적 사용하지 않는 것을 권장.
  - 객체안에서의 any 느낌?
- {} : 객체의 속성 타입을 지정해줄 때 사용.
  - {} 를 타입으로 지정하는 경우 속성을 추가할 수 없음
  - {} 더라도 프로토타입 체이닝으로 Object 객체 래퍼에서 제공하는 속성에는 정상적으로 접근 가능.
- array : Array 키워드 / [] 로 선언 가능.
- type vs interface 키워드 : {} 대신 사용할 수 있는 객체 타입 지정 방식
- function : 호출 시그니처 ((매개변수 타입) ⇒ 반환 타입) 으로 함수의 타입 정의
  - 호출 시그니처는 화살표 함수 방식으로 작성함.
