# 2장 타입

## 타입 결정 시점에 따른 분류

타입을 결정하는 시점에 따라 타입을 **정적 타입**과 **동적 타입**으로 분류합니다.

### 정적 타입 (Static Typing)

- 모든 변수에 타입이 **컴파일타임에 결정**
- 코드 수준에서 개발자가 타입을 명시해줘야 하는 언어
  - C, Java, TypeScript 등이 정적 타입 언어에 속함
- **장점**: 컴파일타임에 타입 에러를 발견할 수 있어 안정성 보장

### 동적 타입 (Dynamic Typing)

- 변수 타입이 **런타임에 결정**
- Python, JavaScript 등이 동적 타입 언어에 속함

> 💡 **참고**: 타입이 결정되는 시점만 다를 뿐, 모든 프로그래밍 언어에는 값의 타입이 존재합니다.

---

## 암묵적 타입 변환에 따른 분류

### ❓암묵적 타입 변환이란

개발자가 의도적으로 타입을 명시하거나 바꾸지 않았는데도 컴파일러 또는 엔진 등에 의해 런타임에 타입이 자동으로 변경되는 것

암묵적 타입 변환 여부에 따라 타입 시스템을 **강타입**과 **약타입**으로 분류합니다.

### 강타입 (Strong Typing)

서로 다른 타입을 갖는 값끼리 연산을 시도하면 컴파일러 또는 인터프리터에서 **에러가 발생**

### 약타입 (Weak Typing)

서로 다른 타입을 갖는 값끼리 연산할 때 컴파일러 또는 인터프리터가 내부적으로 판단해서 **특정 값의 타입을 변환하여 연산을 수행** 후 값을 도출

---

## 타입 일치 방식에 따른 분류

타입 간 호환 여부를 어떻게 판단하느냐에 따른 분류입니다.

### 명목적 타이핑 (Nominal Typing)

**타입 이름(선언) 기반**으로 타입을 구분
- 구조가 같아도 **다른 이름이면 불일치로 간주**

### 구조적 타이핑 (Structural Typing)

**타입의 이름이 아닌, 구조(프로퍼티나 메서드 구성)**로 타입 호환 여부를 판단하는 타입 시스템

#### 특징
- 타입의 구조가 같으면 **다른 타입이라도 호환 가능**
- 추가 속성이 있어도 **필수 속성만 맞으면 통과**
- 익명 객체나 함수도 타입 선언 없이 **자동 추론 및 호환 가능**

### 구조적 서브 타이핑 (Structural Subtyping)

객체가 가지고 있는 속성을 바탕으로 타입을 구분하는 메커니즘으로, **타입스크립트의 타입 시스템을 지탱하고 있는 개념**입니다.

한 타입이 다른 타입의 구조를 **부분적으로 포함**하여 호환될 수 있는 원리입니다.

```tsx
type Super = { name: string };
type Sub = { name: string; age: number };

const s: Super = { name: "Tom" };
const sub: Sub = { name: "Tom", age: 30 };

const compatible: Super = sub; // ✅ 구조적 서브타이핑에 의해 허용
```

Sub는 Super보다 속성이 많지만, Super가 요구하는 구조를 완전히 포함하고 있으므로 **서브타입**으로 간주됩니다.

---

## 타입스크립트가 구조적 타이핑을 채택한 이유

**자바스크립트를 모델링한 언어**이기 때문입니다.

자바스크립트는 본질적으로 **덕 타이핑(Duck Typing)**을 기반으로 합니다.

> **덕 타이핑**: 어떤 함수의 매개변수값이 올바르게 주어진다면 그 값이 어떻게 만들어졌는지 신경쓰지 않고 사용한다는 개념

타입스크립트는 이를 그대로 모델링하여 자바스크립트의 특징을 그대로 받아들여 구조적 타이핑 방식을 채택했습니다. **쉬운 사용성과 안정성**을 목표로 합니다.

### 덕 타이핑과 구조적 타이핑의 차이

**타입을 검사하는 시점**이 다릅니다:

- **덕 타이핑**: 런타임에 타입을 검사
- **구조적 타이핑**: 컴파일타임에 타입을 검사

---

## 값과 타입 공간에 동시에 존재하는 심볼

- `class`
- `enum`

---

## Type vs Interface

### `type`을 사용하는 경우

- 교차 타입(`&`)이나 유니온 타입(`|`)을 사용할 때 (간결한 타입 정의가 필요한 경우)

### `interface`를 사용하는 경우

- 객체 타입을 계층적으로 확장하거나 병합(Merging)해야 할 때
- 객체 위주의 구조 설계를 많이 할 때

---

## 호출 시그니처 (Call Signature)

함수 자체의 타입을 지정하는 방법입니다.

```tsx
type Add = (a: number, b: number) => number;
```
