### 타입확장

### 유니온타입

### 교차타입

```tsx
interface Person {
	name: string;
	age: number;
}

interface Book {
	title: string;
}

type Intersection = Book & Person
```

<aside>
💡

교차타입 = 교집합

유니온타입 = 합집합

*교차타입을 교집합으로 설명한다면, 교집합은 없는게 아닌가?*

⇒  구조적 타이핑에 기반하여 생각해야함.

교집합이 되려면 그 교집합을 `Person` 으로 간주하거나, `Book` 으로 간주해도 무리가 없어야한다.

즉, 타입 관점에서 `Person`에도 속하고, `Book` 에도 속하는 타입이므로 교집합

</aside>

타입스크립트의 타입을 속성의 집합이 아닌 값의 집합으로 이해해야 한다.

- ***extends 키워드를 사용한 타입과 교차타입은 100% 상응하지 않음***
    


**상황**

배달 서비스 메뉴에서 특정 메뉴의 중요도를 다르게 주기 위한 요구 사항이 추가 됨.

1. 특정 메뉴를 길게 누르면 gif 파일이 재생되어야 한다.
2. 특정 메뉴는 이미지 대신 별도의 텍스트만 노출되어야 한다.

요구 사항을 만족하는 타입의 작성 방법을 2가지로 생각해볼 수 있다.
<img width="808" height="1014" alt="ss" src="https://github.com/user-attachments/assets/41ba8aeb-05d7-47a8-b764-29efe75e8724" />



- 무분별하게 하나의 타입에 속성을 추가하여 사용하는 것보다 타입을 확장해서 사용하는것이 좋음
    - 적절한 네이밍을 통한 명확한 의도
    - 예기치 못한 버그 예방
        - 예시 131p

### 구별된 유니온(discriminated union) | 태그된 유니온(tagged union)

```tsx
type TextError = {
  errorCode: string; 
  errorMessage: string;
}
type ToastError = {
  errorCode: string; 
  errorMessage: string;
  toastShowDuration: number; // 토스트를 띄워줄 시간
}
type AlertError = {
  errorCode: string; 
  errorMessage: string;
  onConfirm: () => void;
}

type ErrorFeedbackType = TextError | ToastError | AlertError;

const errorArr: ErrorFeedbackType[] = [
  { errorCode: "100", errorMessage: "텍스트 에러" },
  { errorCode: "200", errorMessage: "토스트 에러", toastShowDuration: 3000 },
  { errorCode: "300", errorMessage: "얼럿 에러", onConfirm: () => { } },
]

const errorArrs: ErrorFeedbackType[] = [
  {
    errorCode: "999",
    errorMessage: "잘못된 에러",
    toastShowDuration: 3000,  // expected error
    onConfirm: () => { },     // expected error
  }, 
]

// OK 정상 동작
```

expected error: **`errorCode`**와 **`errorMessage`**를 제외한 나머지 속성

**에러가 발생하지 않는이유**

- 객체 리터럴이므로 fresh 객체로 판단하여 초과 프로퍼티 검사를 해야하지만 유니온 타입인 경우는 모든 필요한 속성(errorCode, errorMessage)을 포함하고 있다면, 추가 속성이 있어도 TypeScript는 이를 허용

예를 들어, 태그된 유니온을 사용하거나 각 타입에 대한 명시적인 구분자를 추가할 수 있습니다.

### Exhaustiveness Checking
<img width="624" height="373" alt="스크린샷 2025-01-08 오후 3 12 50" src="https://github.com/user-attachments/assets/b07fa9d6-848d-426d-ac64-001488db755d" />


위 코드의 `else`블럭에서 `throw new Error(`Unhandled case in `);`와 같이 사용한다면 런타임에 타입 에러가 발생하게 되는데 **Exhaustiveness Checking**을 사용한다면 컴파일 타임에 타입 검사를 통해 에러를 알아차릴 수 있다.

```tsx
// context를 받음으로써 특정 타입에러를 발생시킬 수 있도록 함

const exhaustiveCheck = (param: never, context: string): void => {
	throw new Error(`Unhandled case in ${context}: ${param}`);
};
```
