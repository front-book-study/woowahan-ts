## 4.1 ] 타입 확장

### 타입 확장의 장점

---

- 중복을 줄일 수 있음
- 요구사항 변경에 대응하기 수월 → 기존의 타입을 확장해서 새로운 타입을 추가하면 됨.
- 유지보수에 용이 → 베이스 타입만 수정하면 다른 확장 타입들은 자동적으로 수정사항 반영됨.

### 확장 방법1. Type 사용 - 유니온 타입 / 교차 타입

---

- 리터럴 타입
    - 유니온 : 합집합
    - 교차 : 교집합
- 객체 타입
    - 유니온 : 분기 (둘 중 하나)
    - 교차 : 합성 (둘 다 만족)

```tsx
type Fruit = "apple" | "banana";
type Color = "red" | "yellow";

// 유니온 → 합집합
type U = Fruit | Color;
// "apple" | "banana" | "red" | "yellow"

// 교차 → 교집합
type I = Fruit & Color;
// never (겹치는 원소 없음)
```

```tsx
type A = { id: number };
type B = { name: string };

// 유니온 → 둘 중 하나만 있으면 됨
type U = A | B;
// {id: number} | {name: string}

// 교차 → 둘 다 있어야 함
type I = A & B;
// {id: number, name: string}
```

### 확장 방법2. Interface 사용 - extends

---

```tsx
interface Base { id: string }
interface User extends Base { name: string }
```

### interface extends vs type &

---

|  | Extends | & 교차 타입 |
| --- | --- | --- |
| 확장 방법 | interface extends  | type &  |
| 충돌처리  | 속성 타입이 다르면 컴파일 에러 발생 | 속성 타입이 다르면 never 타입이 됨 |
| 에러 메시지 | 충돌시 에러발생해서 디버깅에 용이 | never로 되어서 디버깅에 용이하지 않을 수 있음 |
| 선언 병합 | 가능 같은 이름으로 선언시 자동 병합) | 불가 |
| 클래스 확장 | 가능 | 불가 |
| 활용도 추천 | 점진적 확장, 라이브러리 타입 보강, 객체 지향적 구조 설계 | 복잡한 타입조합, 고급 타입 변환 |

### 하나의 타입에 여러 속성 추가 vs 확장

---

```tsx
const menuList = [ 
	{ name: '찜', image: '찜.png' },
	{ name: '찌개', image: '찌개.png' },
	{ name: '회', image: '회.png' },
}

const specialMenuList = [
	{ name: '돈까스', image: '돈까스.png', gif: '돈까스.gif' },
  { name: '피자', image: '피자.png', gif: '피자.gif' }
}

const packageMenuList = [
	{ name: '1인분', image: '1인분.png', text: '1인 가구 맞춤형' },
  { name: '족발', image: '족발.png', text: '오늘은 족발로 결정' }
}
```

1. 하나의 타입에 여러 속성 추가

```tsx
interface Menu {
	name: string;
	image: string; 
	gif?: string;    //추가된 요구사항 1: gif
	text?: string;   //추가된 요구사항 2: 이미지 대신 별도 텍스트만 노출
}
```

```tsx
menuList:Menu[];
specialMenuList:Menu[];
packageMenuList:Menu[];

specialMenuList.map(menu => menu.text); 
//TypeError: Cannot read properties of undefined
```

Menu라는 타입에 text가 있지만 optional이기 때문에 specialMenuList의 경우 text가 없어서 undefined로 뜸.

1. 타입을 확장하는 방식

```tsx
type Menu = {
  name: string;
  image: string;
}

type SpecialMenu = Menu & {
  gif: string;
}

type PackageMenu = Menu & {
  text:string;
}
```

```tsx

const specialMenuList: SpecialMenu[] = []
specialMenuList.map(menu => menu.text)
//Property 'text' does not exist on type 'SpecialMenu'.(2339)
```

Menu 타입이 아닌 SpecialMenu 타입에 text라는 속성이 없어서 접근이 불가능한다는 에러가 뜸.

## 4.2 ] 타입 좁히기 - 타입 가드

### 타입 가드

**런타임**에 조건문을 사용해서 타임 검사를 하고 타입 범위를 좁혀주는 기능

타입 가드가 필요한 경우 - ex) 여러 타입의 유니온으로 구성된 타입이 있을 때 각 타입마다 분기처리를 해주고 싶을 때

if 문으로 처리해서 특정 타입인 경우 분기처리를 태워도 될 것 같지만 **타입은 컴파일 과정에서 모두 제거**되기 때문에 런타임에 존재하지 않음. **따라서 컴파일 이후에도 살아남는 조건문인 필요함!!** 

- 자바스크립트 연산자를 활용한 타입 가드 - typeof, instanceof, in 연산자  : 타입스크립트뿐만 아니라 컴파일 이후 자바스크립트에서도 사용될 수 있어 런타임에도 유효함.
- 사용자 정의 타입 가드 -

### 방법1. typeof 연산자 (JS) - 원시 타입 추론할 때

---

- typeof는 자바스크립트 타입 시스템만 대응가능
- string, number, boolean, undefined, object, function, bigint, symbol 검사 가능
- object안에 null, 배열, object, Date, 정규표현식, class가 포함됨
- number안에 NaN, Infinity 포함됨
- 따라서, 복잡한 타입 검증에는 한계가 있으므로 사용에 주의

**`헷갈렸던 개념`**

typeof 연산자는 타입스크립트, 자바스크립트에 모두 있는 연산자인데 타입가드에서 자바스크립트 typeof 연산자를 사용하는 이유. 타입가드는 조건문을 이용해서 분기처리하는 로직이기 때문에 if 조건문을 사용. if 조건문은 런타임에 실행되는 코드이기 때문에 타입스크립트가 아닌 자바스크립트 코드가 필요. 타입스크립트의 typeof는 타입 공간에만 쓰일 수 있으며 (타입에 할당되는 값으로써만 사용됨) 컴파일 단계에서 사라지기 때문에 런타임에 사용될 수 없음. 타입스크립트에서는 if 조건문의 런타임 코드를 보고 좁혀진 타입을 추론함.

### 방법 2. instanceof 연산자 (JS) - 인스턴스화된 객체 타입 판별할 때

---

- typeof = 원시타입 판별할 때 사용
- instanceof = 인스턴스화된 객체 타입 판별할 때 사용
- A instanceof B :
    - A = 타입 검사 대상
    - B = 기준이 되는 객체 생성자
    - 반환값  = 존재하면 true, 존재하지 않으면 false
    
- instanceof로 검사 가능한 것
    
    
    | 타입 / 클래스 | 사용 가능 여부 | 예시 |
    | --- | --- | --- |
    | `Date` | ✅ 가능 | `value instanceof Date` |
    | `RegExp` | ✅ 가능 | `value instanceof RegExp` |
    | `Error` | ✅ 가능 | `value instanceof Error` |
    | `Array` | ✅ 가능 | `value instanceof Array` |
    | 사용자 정의 클래스 | ✅ 가능 | `value instanceof MyClass` |
    | `Function` | ✅ 가능 | `value instanceof Function` |
    | `Map`, `Set`, `WeakMap`, `WeakSet` | ✅ 가능 | `value instanceof Map` 등 |
- instanceof로 검사 불가능한 것
    
    
    | 타입 | 설명 |
    | --- | --- |
    | `string`, `number`, `boolean` (primitive) | `instanceof`는 **객체**만 검사 가능 |
    | `interface`, `type alias` | 타입스크립트의 타입은 **런타임에 존재하지 않음** |
    | `null`, `undefined` | 당연히 `instanceof` 불가 |

### 방법 3. in 연산자 (JS) - 객체의 속성 존재 여부 판별할 때

---

- 객체에 해당 속성이 있는지 확인한 후 있으면 true, 없으면 false 반환
- 주의할점은 속성값이 falsy ≠ 속성이 아예 존재하지 않음
    - 속성값이 null, undefined라고 해서 속성이 없다고 판별하지 않음.
- in 연산자는 자바스크립트 런타임에 실행되는 연산자 **BUT 타입스크립트에서는 타입 가드로 인식해서 타입을 좁혀주는 역할을 함! 타입스크립트가 정적으로 분석해서 타입 추론에 활용.**

### 방법 4. is 연산자 (TS) - 사용자 정의 타입 가드 만들어서 활용

---

- is 연산자는 타입스크립트에서만 사용되는 연산자
- 타입스크립트에서 타입가드로 사용되는 연산자
- 반환값에 대한 타입 정보를 알려주고 싶을 때 사용됨

- 반환값은 boolean
- 반환 타입은 `A is B`  로 명시
    - **A라는 값이 B라는 타입임으로 주장**하는 것
    - 이 문장을 **타입 명제 (type predicate)**이라고 부름
    - true일 때 A는 B 타입으로 추론됨.

```tsx
type Dog = { kind: 'dog'; bark: () => void };
type Cat = { kind: 'cat'; meow: () => void };
type Animal = Dog | Cat;

function isDog(animal: Animal): animal is Dog {
  return animal.kind === 'dog';
}

const pet: Animal = getPet(); // api 호출

if (isDog(pet)) {
  // 여기서 pet은 타입스크립트가 Dog으로 추론함
  pet.bark(); // ✅ OK
} else {
  pet.meow(); // ✅ 여기서는 Cat으로 추론
}
```

## 4.3 ] 타입 좁히기 - 식별할 수 있는 유니온  (Discriminated Unions)

---

- 타입스크립트에서는 유니온 타입을 속성의 합집합으로 인식
- 이로 인해서 A | B | C 중 하나의 타입으로 귀결되지 않아도 에러가 발생하지 않는 문제가 발생.
- 이를 해결하기 위해 Discriminated Union 등장
- 식별자를 지정해줌으로써 A | B | C 타입을 명확하게 구별지어줌.

`헷갈렸던 부분`

- 일반 유니온은 속성의 합집합처럼 동작 근데 왜 식별자를 추가한다고 분리된 타입처럼 동작하는거지?
    - 유니온은 사실 합집합이 아니고 A 일 수 있고, B일 수도 있어. 근데 부분적으로 맞아도 상관없어라고 판단.
    - 이때는 타입 좁히기가 불가능. A일 수도 있고 B일 수 있어서.
    - 하지만, 식별자가 있으면 명확히 타입 좁히기가 가능
    
    ⇒ 결론 : 식별자가 없을때는 A일수도 있고 B일 수 있어라고 느슨하게 생각. 하지만 식별자가 있으면 명확히 타입 구분해서 타입 좁혀서 사용 가능!
    

- 식별자가 없을 때

```tsx
type A = { a: string };
type B = { b: number };
type AB = A | B;

const x: AB = { a: "hi", b: 123 }; // ❓ 통과할 때도 있음

// 타입 좁히기 불가
function handle(x: A | B) {
  if ('a' in x) {
    x.a; // OK
    x.b; // ❌ Error — B 타입일 수도 있으니까
  }
}
```

- 식별자가 있을 때

```tsx
type Dog = { type: 'dog'; bark: () => void };
type Cat = { type: 'cat'; meow: () => void };
type Animal = Dog | Cat;

function handle(a: Animal) {
  if (a.type === 'dog') {
    a.bark(); // ✅ 타입스크립트가 자동으로 Dog로 좁힘
  }
}
```

- 식별자로 쓸 수 있는 값

| 타입 | 리터럴 예시 | 식별자 사용 가능 여부 | 조건 |
| --- | --- | --- | --- |
| `string` | `'text'` | ✅ 사용 가능 | 리터럴이어야 함 |
| `number` | `1`, `404` | ✅ 사용 가능 | 리터럴이어야 함 |
| `bigint` | `1n`, `1000n` | ✅ 사용 가능 | TS 4.0 이상, 리터럴 |
| `symbol` | `unique symbol` | ⚠️ 제한적 사용 가능 | `declare const`, `typeof`, `unique symbol` |
| `boolean` | `true` / `false` | ✅ 가능 (희귀하지만 가능) | 리터럴일 경우에만 |
| `null` `undefined` | `null` / `undefined` | ✅ 사용 가능 | 리터럴일 경우에만 |
| 그 외 | `any`, `object`, etc. | ❌ 불가능 | 값 비교가 불가능하거나 추론 불가 |

## 4.4 ] Exhaustive Check으로 정확한 타입 분기 유지

---

- 모든 타입의 분기 처리를 강제하고 싶을 때 사용

`문법`

- n을 exhaustiveCheck라는 never 타입 변수에 할당함.
    - n이 모든 케이스 처리가 끝났다면 이때 n은 never이기 때문에 에러 발생 X
    - n의 모든 케이스 처리가 끝나지 않았다면 이때 n은 never이 아니기 때문에 타입에러 발생 O
        
        → throw new Error 실행됨
        

```tsx
type Notification =
  | { type: 'email'; address: string }
  | { type: 'sms'; phone: string }
  | { type: 'push'; deviceId: string };

function handleNotification(n: Notification) {
  switch (n.type) {
    case 'email':
      console.log(`📧 Email: ${n.address}`);
      break;
    case 'sms':
      console.log(`📱 SMS: ${n.phone}`);
      break;
    case 'push':
      console.log(`🔔 Push: ${n.deviceId}`);
      break;
    **default:
      // ✅ 이 블록은 절대로 실행되면 안 됨
      // 타입스크립트는 여기서 n의 타입이 `never`여야 안전하다고 본다
      const _exhaustiveCheck: never = n;
      throw new Error(`Unhandled type: ${JSON.stringify(n)}`);**
  }
}
```

`함수로 로직 모듈화`

- 위처럼 로직을 작성해도 되지만, 재사용성을 위해 함수로 모듈화도 가능
- throw new Error의 경우 반환타입이 never

```tsx
function assertNever(x: never): never {
  throw new Error(`Unexpected value: ${JSON.stringify(x)}`);
}

switch (something.kind) {
  case 'a':
  case 'b':
    break;
  default:
    assertNever(something);
}
```