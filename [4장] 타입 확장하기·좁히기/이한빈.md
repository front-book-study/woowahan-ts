# `4.1` 타입 확장하기
> 기존 타입을 사용해서 새로운 타입을 정의하는 것

- `interface`, `type` 키워드를 통해 타입을 정의
- `extends`, 교차 타입, 유니온 타입을 사용하여 **타입을 확장**

<br>

## 1. 타입 확장의 장점
> 타입 확장의 가장 큰 장점은 **코드 중복을 줄일 수 있다는 것**

중복되는 타입을 반복적으로 선언<br>
→ 기존에 작성한 타입을 바탕으로 확장을 함으로써 불필요한 코드 중복 줄임

#### 예제 1
```ts
// 메뉴 요소 타입
// 메뉴 이름, 이미지, 할인율, 재고 정보를 담고 있음
interface BaseMenuItem {
    itemName: string | null;
    itemImageUrl: string | null;
    itemDiscountAmount: number;
    stock: number | null;
}

// 장바구니 요소 타입
// 메뉴 타입에 수량 정보가 추가됨
interface BaseCartItem extends BaseMenuItem {
    quantity: number; // 수량 정보
}
```
- 장바구니 요소는 메뉴 요소가 갖는 모든 타입이 필요함
- 속성을 중복해서 작성하지 않고 BaseMenuItem을 extends(확장)해서 활용
- 중복된 코드를 줄였고 BaseCartItem이 BaseMenuItem에서 확장됐다는 게 명시적으로 확인 가능 

<br>

> `interface` 대신 `type`을 쓴 예제

```ts
type BaseMenuItem {
    itemName: string | null;
    itemImageUrl: string | null;
    itemDiscountAmount: number;
    stock: number | null;
}

type BaseCartItem {
    quantity: number;
}
```
<br>

> 타입 확장은 중복 제거, 명시적인 코드 작성 외에도 **확장성**이라는 장점을 가지고 있음

```ts
// 수정할 수 있는 장바구니 요소 타입
// 품절 여부, 수정할 수 있는 옵션 배열 정보가 추가됨
interface EditableCartItem extends BaseCartItem {
    isSoldOut: boolean;
    optionGroups: SelectableOptionGroup[];
}

// 이벤트 장바구니 요소 타입
// 주문 가능 여부에 대한 정보가 추가됨
interface EventCartItem extends BaseCartItem {
    orderable: boolean;
}
```
- BaseCartItem을 확장해서 만든 EditableCartItem, EventCartItem 타입
- 타입 확장을 통해 장바구니와 관련된 요구 사항이 생길 떄마다 필요한 타입을 쉽게 만들 수 있음
- 기존 장바구니 요소에 대한 요구사항이 변경되어도, BaseCartItem만 수정하면 돼서 효율적

<br>

## 2. 유니온 타입

```ts
type MyUnion = A | B;
```
유니온 타입으로 선언된 값은 유니온 타입에 포함된 모든 타입이 공통으로 갖고 있는 속성에만 접근할 수 있음.

<br>

## 3. 교차 타입
유니온 타입과 다르게, 모든 타입을 합쳐 모든 속성을 가진 단일 타입이 됨.

<br>

## 4. extends와 교차 타입

유니온 타입과 교차 타입을 사용한 새로운 타입은 오직 **type 키워드**로만 선언할 수 있음.

extends 키워드를 사용한 타입이 **교차 타입과 100% 상응하지는 않는다는 것**을 주의.
```ts
interface DeliveryTip {
    tip: number;
}

interface Filter extends DeliveryTip {
    tip: string;
    // 🚨 Interface 'Filter' incorrectly extends interface 'DeliveryTip'.
    // Types of property 'tip' are incompatible.
    // Type 'string' is not assignable to type 'number'.
}
```
- tip의 타입이 호환되지 않는다는 에러 발생

<br>

#### 같은 예시를 교차 타입으로 작성
```ts
interface DeliveryTip {
    tip: number;
}

type Filter = DeliveryTip & {
    tip: string;
}
```
- 에러 발생 X
- 이때 tip 속성의 타입은 **never 타입**
- number과 string은 공통 부분이 없으니 never가 되어버린 것

### 결론
- extends는 겹치면 안 돼! 하며 오류를 내는 엄격한 검사관
- type의 `&` 교차 타입은 에러 대신 교집합을 계산 해버림

<br>

## 5. 배달의민족 메뉴 시스템에 타입 확장 적용하기

### 방법 1. 하나의 타입에 여러 속성을 추가할 때

```ts
interface Menu {
    name: string;
    image: string;
    gif?: string;
    text?: string;
}

const specialMenuList:Menu[];

specialMenuList.map((menu) => menu.text);
// Type Error 발생
```
specialMenuList는 Menu 타입 원소를 갖기 때문에 text 속성에도 접근할 수 있지만,<br>
모든 원소가 text 속성을 갖고 있지는 않으므로 에러 발생🚨

### 방법 2. 타입을 확장하는 방식

```ts
const menuList: Menu[];

const specialMenuList: Menu[]; // X
const specialMenuList: SpecialMenu[]; // ✅

const packageMenuList: Menu[]; // X
const packageMenuList: PackageMenu[]; // ✅


specialMenuList.map((menu) => menu.text);
// Property 'text' does not exist on type 'SpecialMenu'
```
프로그램을 실행하지 않고도 타입이 잘못되었음을 미리 알 수 있음.

<br>

> ### 결론 
> 주어진 타입에 무분별하게 속성을 추가하여 사용하는 것보다, 타입을 확장해서 사용하는 게 👍🏻<br> 적절한 네이밍을 사용해서 타입의 의도를 명확히 표현할 수도 있고, 코드 작성 단계에서 예기치 못한 버그도 예방할 수 있기 때문.

<br>
<br>
<br>

# `4.2` 타입 좁히기 - 타입 가드
TS에서 타입 좁히기는 변수 or 표현식의 타입 범위를 더 작은 범위로 좁혀나가는 과정을 의미<br><br>타입 좁히기를 통해 더 정확하고 명시적인 타입 추론이 가능해지고, 복잡한 타입을 작은 범위로 축소하여 타입 안정성을 높일 수 있음.

<br>

## 1. 타입 가드에 따라 분기 처리하기
> TS에서 분기 처리는 조건문과 타입 가드를 활용해 변수 or 표현식의 타입 범위를 좁혀 다양한 상황에 따라 다른 동작을 수행하는 것을 의미. 타입 가드는 런타임에 조건문을 사용하여 타입을 검사하고 타입 범위를 좁혀주는 기능을 말함.

#### 상황 가정
> 어떤 함수가 `A | B` 타입의 매개변수를 받는다고 가정. 인자 타입이 A 또는 B일 때를 구분해서 로직을 처리하고 싶다면 어떻게 해야 할까?

<br>if문을 사용하면 될 것 같지만, 컴파일 시 타입 정보는 모두 제거되어 런타임에 존재하지 않기 때문에 타입을 사용하여 조건을 만들 수는 없음. 즉, **컴파일해도 타입 정보가 사라지지 않는 방법을 사용**해야 함.

<br>

## 2. 원시 타입을 추론할 때: `typeof` 연산자 활용하기
`typeof A === B`를 조건으로 분기 처리하면, 해당 분기 내에서는 A의 타입이 B로 추론됨. 다만 typeof는 JavaScript 타입 시스템만 대응할 수 있음. 따라서 typeof 연산자는 주로 **원시 타입을 좁히는 용도로만 사용할 것**을 권장

- typeof 연산자로 검사할 수 있는 타입: `string`, `number`, `boolean`, `undefined`, `object`, `function`, `bigint`, `symbol`

```ts
const replaceHyphen: (date: string | Date) => string | Date = (date) => {
    if (typeof date === "string"){
        // 이 분기에서는 date의 타입이 string으로 추론됨
        return date.replace(/-/g, "/");
    }
    return date;
}
```
<br>

## 3. 인스턴스화된 객체 타입을 판별할 때: `instanceof` 연산자 활용하기

```ts
interface Range {
    start: Date;
    end: Date;
}

interface DatePickerProps {
    selectedDates?: Date | Range;
}

const DatePicker = ({ selectedDates }: DatePickerProps) => {
    const [selected, setSelected] = useState(convertToRange(selectedDates));
}

export function convertToRange(selected?: Date | Range): Range | undefined{
    return selected instanceof Date
        ? { start: selected, end: selected }
        : selected;
}
```
typeof를 주로 원시 타입을 판별하는 데 사용한다면, instanceof는 인스턴스화된 객체 타입을 판별하는 타입 가드로 사용할 수 있음. `A instanceof B` 형태에서 A에는 타입을 검사할 대상 변수, B에는 특정 객체의 생성자가 들어감.

<br>

## 4. 객체의 속성이 있는지 없는지에 따른 구분: `in` 연산자 활용하기

> in 연산자는 객체에 속성이 있는지 확인하여 true or false 반환<br>A in B 형태로 상요하는데 B 객체 내부에 A 속성의 유무를 검사하는 것이기 때문에 B 객체에 존재하는 A 속성에 undefined를 할당한다고 해서 false를 반환하는 것은 아님. delete 연산자를 사용해서 객체 내부에서 해당 속성을 제거해야만 false 반환.

자바스크립트의 in 연산자는 런타임의 값만을 검사하지만 타입스크립트에서는 객체 타입에 속성이 존재하는지를 검사함.

<br>

## 5. is 연산자로 사용자 정의 타입 가드 만들어 활용하기

> 반환 타입이 타입 명제(type predicates)인 함수를 정의하여 사용. A is B 형식으로 작성하는데 A는 매개변수 이름이고 B는 타입.<br>반환 값이 참일 때 A 매개변수 타입을 B 타입으로 취급하게 됨.

<br>

```ts
const isDestinationCode = (x: string): x is DestinationCode =>
    destinationCodeList.includes(x);
```
string 타입의 매개변수가 destinationCodeList 배열의 원소 중 하나인지를 검사하여 boolean 반환하는 함수
<br>

- `boolean` 반환 = "맞다/틀리다만 알려줌”
- `x is SomeType` 반환 = “맞으면 x는 SomeType임까지 보장해줌”

<br>
<br>
<br>

# `4.3` 타입 좁히기 - 식별할 수 있는 유니온(Discriminated Unions)

- 종종 태그된 유니온(Tagged Union)으로도 불림
- 타입 좁히기에 널리 사용되는 방식

<br>

## 1. 에러 정의하기

배달의 민족 선물하기 서비스는 선물을 보낼 때 필요한 값을 사용자가 올바르게 입력했는지 확인하는 유효성 검사를 진행함.

유효성 에러가 발생하면 사용자에게 다양한 방식으로 에러를 보여주는데
- 텍스트 에러
- 토스트 에러
- 얼럿 에러

로 분류함.

<br>

```ts
type TextError = {
    errorCode: string;
    errorMessage: string;
};
type ToastError = {
    errorCode: string;
    errorMessage: string;
    toastShowDuration: number; // 토스트를 띄워줄 시간
};
type AlertError = {
    errorCode: string;
    errorMessage: string;
    onConfirm: () => void; // alert 창의 확인 버튼을 누른 뒤 액션
};

type ErrorFeedbackType = TextError | ToastError | AlertError;

const errorArr: ErrorFeedbackType[] = [
    { errorCode: "100", errorMessage: "텍스트 에러" },
    { errorCode: "200", errorMessage: "토스트 에러", toastShowDuration: 3000 },
    { errorCode: "300", errorMessage: "얼럿 에러", onConfirm: () => {} },
];
```
ToastError의 toastShowDuration 필드와 AlertError의 onConfirm 필드를 **모두 가지는 객체**에 대해서는 타입 에러를 뱉어야 함.

<br>

```ts
const errorArr: ErrorFeedbackType[] = [
    // ...
    { 
        errorCode: "999",
        errorMessage: "잘못된 에러",
        toastShowDuration: 3000,
        onConfirm: () => {}, 
    }, // expected error
];
```
하지만 이 코드에서는, 자바스크립트는 덕 타이핑 언어이기 때문에 별도의 타입 에러를 뱉지 않는 것을 확인할 수 있음. 이런 상황에서 타입 에러가 발생치 않는다면 앞으로 개발 과정에서 **의미를 알 수 없는 무수한 에러 객체가 생겨날 위험성**🚨

<br>

➡️ 따라서 **에러 타입을 구분할 방법이 필요**함

## 2. 식별할 수 있는 유니온

각 타입이 비슷한 구조를 가지지만 서로 호환되지 않도록 만들어주기 위해 **타입들이 서로 포함 관계를 가지지 않도록 정의**해야 함.

이때 타입 간의 구조 호환을 막기 위해 타입마다 구분할 수 있는 판별자(discriminant)를 달아주어 포함 관계를 제거하는 "**식별할 수 있는 유니온✅**"을 활용

```ts
type TextError = {
    errorType: "TEXT"; // 판별자 ✅
    errorCode: string;
    errorMessage: string;
};
type ToastError = {
    errorType: "TOAST"; // 판별자 ✅
    errorCode: string;
    errorMessage: string;
    toastShowDuration: number; // 토스트를 띄워줄 시간
};
type AlertError = {
    errorType: "ALERT"; // 판별자 ✅
    errorCode: string;
    errorMessage: string;
    onConfirm: () => void; // alert 창의 확인 버튼을 누른 뒤 액션
};

type ErrorFeedbackType = TextError | ToastError | AlertError;

const errorArr: ErrorFeedbackType[] = [
    { errorType: "TEXT", errorCode: "100", errorMessage: "텍스트 에러"},
    
    // ...

    {
        errorType: "TEXT",
        errorCode: "999",
        errorMessage: "잘못된 에러",
        toastShowDuration: 3000,
        // Object literal may only specify known properties, and 'toastShowDuration' does not exist in type 'TextError'.
        onConfirm: () => {}, 
    },
];
```
처음에 기대했던 대로 정확하지 않은 에러 객체에 대해 타입 에러가 발생하는 것을 확인할 수 있음.

<br>

## 3. 식별할 수 있는 유니온의 판별자 선정
식별할 수 있는 유니온을 사용할 때 주의할 점이 있음.<br>판별자는 다른 타입으로 쪼개지지 않고 오직 하나의 정확한 값을 가지는 타입인 **유닛 타입**(unit type)으로 선언돼야 정상적으로 동작함.

- null, undefined, 리터럴 타입을 비롯해 true, 1 등 정확한 값을 나타내는 타입이 유닛 타입에 해당
- 반면 void, string, number 처럼 다양한 타입을 할당할 수 있는 타입은 유닛 타입 X

> #### [공식 GitHub 이슈 탭 - 식별할 수 있는 유니온의 판별자로 가능한 타입](https://github.com/microsoft/TypeScript/issues/30506#issuecomment-474802840)
> 1. 리터럴 타입이어야 함.<br>
> 2. 판별자로 선정한 값에 적어도 하나 이상의 유닛 타입이 포함되어야 하며, 인스턴스화할 수 있는 타입(instantiable type)은 포함되지 않아야 함.

<br>
<br>
<br>

# `4.4` Exhaustiveness Checking으로 정확한 타입 분기 유지하기

> `Exhaustiveness` : ⓝ 철저함, 완전함<br>
> = 모든 케이스에 대해 철저하게 타입을 검사하는 것을 의미

타입 가드를 통해 타입에 대한 분기 처리를 필요한 부분만 할 수도 있지만,<br>때로는 **모든 케이스에 대해 분기 처리를 해야만 유지보수 측면에서 안전하다고 생각되는 상황**도 생김. 

<br>

## 1. 상품권

```ts
// 상품권 가격에 따라 상품권 이름을 반환해주는 함수
type ProductPrice = "10000" | "20000";

const getProductName = (productPrice: ProductPrice): string {
    if(productPrice === "10000") return "배민 상품권 1마넌";
    if(productPrice === "20000") return "배민 상품권 2마넌";
    else {
        return "배민 상품권";
    }
};
```
> 새로운 상품권이 생겨서 ProductPrice 타입이 업데이트되어야 한다고 가정.

<br>

```ts
// 상품권 가격에 따라 상품권 이름을 반환해주는 함수
type ProductPrice = "10000" | "20000" | "5000";

const getProductName = (productPrice: ProductPrice): string => {
    if(productPrice === "10000") return "배민 상품권 1마넌";
    if(productPrice === "20000") return "배민 상품권 2마넌";
    if(productPrice === "5000") return "배민 상품권 5처넌"; // 조건 추가 필요
    else {
        return "배민 상품권";
    }
};
```
이처럼 ProductPrice 타입이 업데이트되면 getProductName 함수도 함께 업데이트되어야 함. productPrice가 "5000"일 경우 조건도 검사하여 의도한 대로 상품권 이름을 반환해야 하지만, getProductName 함수를 수정하지 않아도 **따로 에러가 발생하는 게 아니라서 실수할 여지가** 있음.
<br>

#### 그럼, 모든 타입에 대한 타입 검사를 강제하고 싶다면?

```ts
// 상품권 가격에 따라 상품권 이름을 반환해주는 함수
type ProductPrice = "10000" | "20000" | "5000";

const getProductName = (productPrice: ProductPrice): string => {
    if(productPrice === "10000") return "배민 상품권 1마넌";
    if(productPrice === "20000") return "배민 상품권 2마넌";
    //    if(ProductPrice === "5000") return "배민 상품권 5처넌";
    else {
        exhaustiveCheck(productPrice); 
        // 에러🚨: Argument of type '"5000"' is not assignable to parameter of type 'never'
        return "배민 상품권";
    }
};

const exhaustiveCheck = (param: never) => {
    throw new Error("type error!!");
};
```
- 에러는 ProductPrice 타입 중 5000이라는 값에 대한 분기 처리를 하지 않아서(철저하게 검사하지 않았기 때문에) 발생한 것
- 이와 같이 모든 케이스에 대한 타입 분기 처리를 해주지 않았을 때, 컴파일 타임 에러가 발생하게 하는 것을 **Exhaustiveness Checking** 이라고 함.
- exhaustiveCheck 함수에서는 매개변수가 never 타입이므로, 매개변수로 그 어떤 값도 받을 수 없으며 만일 값이 들어온다면 에러를 내뱉음.
- 이 함수를 타입 처리 조건문의 마지막 else 앞에 사용하면 앞의 조건문에서 모든 타입에 대한 분기 처리를 강제할 수 있음.

<br>

> ### 결론
> Exhaustiveness Checking을 활용하여 **예상치 못한 런타임 에러를 방지**하거나,<br>**요구사항이 변경되었을 떄 생길 수 있는 위험성을 줄일 수 있음**.












