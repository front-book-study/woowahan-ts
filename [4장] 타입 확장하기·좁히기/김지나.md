## 4.1 타입 확장하기
타입확장 : 기존 타입을 사용해서 새로운 타입을 정의하는 것
기본적으로 타입스크립트에서는 `interface`, `type` 키워드로 타입을 정의하고 `extends`, `교차타입`, `유니온 타입`을 이용해 타입을 확장한다.

### 4.1.1 타입 확장의 장점
가장 큰 장점은 코드 중복을 줄일 수 있다. 기존에 작성한 타입을 바탕으로 타입 확장을 함으로써 불필요한 코드 중복을 줄일 수 있다.

### 4.1.2 유니온 타입
유니온 타입은 2개 이상의 타입을 조합해서 사용하는 방법이다(집합 관점에서는 합집합)
유니온 타입으로 선언된 값은 유니온 타입에 포함된 모든 타입이 공통으로 갖고 있는 속성에만 접근할 수 있다.
> 타입스크립트의 타입을 속성의 집합이 아니라 값의 집합이라고 생각해야 유니온 타입이 합집합이라는 개념을 이해할 수 있다
	•	값(value) = 실제 프로그램에서 쓰는 데이터 (숫자, 문자열, 객체 등)
	•	속성(property) = 객체 값이 내부적으로 가진 키-값 쌍
	•	타입 = 특정 조건을 만족하는 값들의 집합
	•	유니온 타입은 값의 관점에서는 합집합,
속성 접근의 관점에서는 교집합만 안전하게 접근 가능

### 4.1.3 교차 타입
유니온 타입과 다르게 교차타입은 타입을 합쳐 모든 속성을 가진 단일 타입이 된다.
유니온 타입이 합집합의 개념이라면 교차타입은 교집합의 개념과 비슷하다. (반대같은데 헷갈리는 부분..)
값 집합 관점
- A | B (유니온) = 합집합 (∪)
- A & B (교차)  = 교집합 (∩)
 
속성 접근 관점 (타입스크립트 타입 체커)
- A | B = 공통 속성만 접근 가능 → 교집합처럼 보임
- A & B = 두 속성이 다 있어야 함 → 합친 것처럼 보임

속성이 아닌 값의 집합으로 이해하자...

```
interface DeliverTip {
    tip:string;
}
interface StarRating {
    rate: number;
}
type Filte = DeliveryTip & StarRating;

const filter:Filter= {
    tip: "1000원 이하",
    rate: 4
}
```
DeliveryTip과 StarRating은 공통된 속성이 없는데 Filter의 타입은 공집합(never)이 아닌 두 타입의 속성을 모두 포함한 타입이 되는데 그 이유는.. => **타입이 속성이 아닌 값의 집합으로 해석되기 때문**
-> 즉, 교차 타입 Filter는 DeliveryTip의 tip 속성과 StarRating의 rate 속성을 모두  만족하는 **값**이 된다.

```
type IdType = string | number;     // { string, number }
type Numeric = number | boolean;   // { number, boolean }
type Universal = IdType & Numeric;
```
Universal의 타입은 string | number | boolean 가 될 것 같지만 교차타입은 교집합이기 때문에 공통적인 number만 가능하다.


### 4.1.4 extends와 교차 타입
```
//interface + extends로 확장
interface BaseMemuItem {
    itemName: string | null;
    itemImageUrl: string| null;
}

interfaceBaseCartItem extends BaseMenuItem{
    quantity: number;
}

// type 키워드 확장
// 유니온티압과 교차 타입을 사용한 새로운 타입은 type키워드만 선언이 가능하다.
type BaseMenuItem = {
    itemName: string | null;
    itemImageUrl: string | null;
}

type BaseCartItem = {
    quantity: number;
} & BaseMenuItem
```
extends 키워드를 사용한 타입이 교차 타입과 100% 상응하지는 않다.
```
interface DeliveryTip {
    tip: number;
}

interface Filter extends DeliveryTip {
    tip: string;
  //  Interface 'Filter' incorrectly extends interface 'DeliveryTip'.
  //  Types of property 'tip' are incompatible.
  //    Type 'string' is not assignable to type 'number'.
}
```
다른 타입을 가진 같은 이름의 속성을 확장했을때 interface에서는 에러가 발생한다. 
하지만 type의 교차타입에서는 에러가 발생하지않고 tip 속성의 타입은 `never`가 된다. type키워드는 교차 타입으로 선언되었을 때 새롭게 추가되는 속성에 대해 미리 알 수 없기때문에 선언 시 에러가 발생하지 않지만 tip이라는 같은 속성에 대해 서로 호환되지 않는 타입이 선언되어 결국 never타입이 되어버린다. 


## 4.2 타입 좁히기 - 타입 가드
타입 좁히기는 변수 또는 표현식의 타입 범위를 더 작은 범위로 좁혀나가는 과정을 말한다. -> 좀 더 정확하고 명시적인 타입 추론을 할 수 있게 되고, 복잡한 타입을 작은 범위로 축소하여 타입 안정성을 높일 수 있다.

###4.2.1 타입 가드에 따라 분기 처리하기
타입스크립트에서의 분기 처리 -> 조건문과 타입 가드를 활용하여 변수나 표현식의 타입 범위를 좁혀 다양한 상황에 따라 다른 동작을 수행하는 것. 
타입 가드 -> 런타임에 조건문을 사용하여 타입을 검사하고 타입 범위를 좁혀주는 기능


만약 A | B 유니온 타입의 값이 있을 때 타입이A인지 B인지 구분하여 로직을 처리하려할때
- if문을 사용해서 처리하지 못함 (컴파일 시 타입 정보는 모두 제거되어 런타임에 존재하지 않음)
=> 컴파일해도 타입 정보가 사라지지 않는 방법을 사용해야 한다.

특정 문맥 안에서 타입스크립트가 해당 변수를 타입 A로 추론하도록 유도하면서 런타임에서도 유효하려면? -> `타입가드` 사용
- 자바스크립트 연산자를 사용한 타입가드(typeof, instanceof, in)
ㄴ 다만 자바스크립트에서도 사용할 수 있는 문법이어야함
- 사용자 정의 타입가드 
- 

### 4.2.2 원시타입을 추론할 때:typeof 연산자 활용하기
typeof 연산자를 사용하면 원시타입에 대해추론할 수 있다. 다만 자바스크립트 타입 시스템만 대응할 수 있으며 자바스크립트의 동작 방식으로 인해 null과 배열 타입 등이 object 타입으로 판별되는 등 복잡한 타입을 검증하기에는 한계가 있다.
typeof 연산자를 사용하여 검사할 수 있는 원시타입 목록
- string
- number
- boolean
- undefined
- object
- function
- bigint
- symbol

### 4.2.3 인스턴스화된 객체 타입을 판별할 때: instanceof 연산자 활용하기
`A instanceof B`형태로 사용하며 A에는 타입을 검사할 대상 변수, B에는 특정 객체의 생성자가 들어간다. instanceof는 A의 프로토타입 체인에 생성자 B가 존재하는지를 검사해서 존재한다면 true, 그렇지 않으면 false를 반환한다. 이러한 동작 방식으로 인해 A의 프로토타입 속성 변화에 따라 instanceof 연산자의 결과가 달라질 수 있다는 점을 유의하자. 

### 4.2.4 객체의 속성이 있는지 없는지에 따른 구분:in 연산자 활용하기
`in` 연산자는 객체에 속성이 있는지 확인한다음에 true또는 false를 반환한다. in 연산자는 `A in B` 형태로 사용하는데 이름 그대로 A라는 속성이 B 객체에 존재하는지를 검사한다. 프로토타입 체인으로 접근할 수 있는 속성이라면 전부 true를 반환한다.
자바스크립트의 in 연산자는 런타임의 값만을 검사하지만 타입스크립트에서는 객체 타입에 속성이 존재하는지를 검사한다. 

### 4.2.5 is 연산자로 사용자 정의 타입가드 만들어 활용하기
직접 타입 가드 함수를 만들 수 있는데 이러한 방식의 타입 가드는 반환 타입이 타입 명제인 함수를 정의하여 사용할 수 있다.
타입 명제는 `A is B` 형식으로 작성하면 되는데 A는 매개변수 이름이고 B는 타입이다. 

// 추후 작성

## 4.3 타입 좁히기 - 식별할 수 있는 유니온(Discriminated Unions)
### 4.3.1 에러 정의하기
```
type TextError = {
    errorCode: string;
    errorMessage: string;
}

type ToastError = {
    errorCode: string;
    errorMessage: string;
    toastShowDuration: number;
}

type AlertError = {
    errorCode: string;
    errorMessage: string;
    onConfirm: () => void;
}

type ErrorFeedbackType = TextError | ToastError | AlertError;

const errorArr: ErrorFeedbackType[] = [
{
    errorCode: "999"
    errorMessage: "에러",
    toastShowDuration: 3000,
    onConfirm: () => {}
}
]

```
자바스크립트는 덕 타이핑 언어이기 때문에 별다른 에러가 발생하지 않는다. 이상황에서 타입 에러가 발생하지 않는다면 앞으로의 개발 과정에서 알 수 없는 무수한 에러 객체가 생길 위험이 커진다.

### 4.3.2 식별할 수 있는 유니온
따라서 에러 타입을 구분할 수 있는 방법이 필요하다. 
각 타입이 비슷한 구조를 가지지만 서로 호환되지 않도록 만들어주기 위해서는 타입들이 서로 포함 관계를 가지지 않도록 정의해야 한다. 이때 적용할 수 있는 방식이 **식별할 수 있는 유니온**을 활용하는 것이다
> 식별할 수 있는 유니온: 타입 간의 구조호환을 막기 위해 타입마다 구분할 수 있는 판별자를 달아 주어 포함 관계를 제거하는 것

```
type TextError = {
    errorCode: "TEXT"
    errorMessage: string;
}

type ToastError = {
    errorCode: "TOAST"
    errorMessage: string;
    toastShowDuration: number;
}

type AlertError = {
    errorCode: "ALERT"
    errorMessage: string;
    onConfirm: () => void;
}
```

### 4.3.3 식별할 수 있는 유니온의 판별자 선정
식별할 수 있는 유니온의 판별자는 `유닛타입`으로 선언되어야 정상적으로 동작한다. 유닛 타입은 다른 타입으로 쪼개지지 않고 오직 하나의 정확한 값을 가지는 타입을 말한다. 
null, undefined, 리터럴 타입을 비롯해 true, 1 등 정확한 값을 나타내는 타입
- 리터럴 타입이어야한다
- 판별자로 선정한 값에 적어도 하나 이상의 유닛 타입이 포함되어야 하며 인스턴스화 할 수 있는 타입은 포함되지 않아야 한다.


## 4.4 Exhaustiveness Checking으로 정확한 타입 분기 유지하기
모든 케이스에 대해 철저하게 타입을 검사하는 것을 말하며 타입 좁하기에 사용되는 패러다임 중 하나다. 
