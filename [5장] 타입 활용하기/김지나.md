## 5.1 조건부 타입
### 5.1.1 extends와 제네릭을 활용한 조건부 타입
`extends` 키워드는 타입을 확장할 때와 타입을 조건부로 설정할 때 사용되며, 제네릭 타입에서는 한정자 역할로도 사용된다. 
> T extneds U ? X : Y

```
interface Bank {...}
interface Card {...}

type PayMethod<T> = T extends "card" ? Card : Bank;
type CardPayMethodType = PayMethod<"card">;
type BankPayMethodType = PayMethod<"bank">;

```
### 5.1.2 조건부 타입을 사용하지 않았을 때의 문제점 
// 유니온 값을 반환하는 사례
- 사용자의 의도와는 다르게 정확한 타입을 반환하지 못한다.
- 인자에 따라 반환되는 타입을 다르게 설정하고 싶다면 extends를 사용한 조건부 타입을 활용하면 된다.

### 5.1.3 extends 조건부 타입을 활용하여 개선하기
- 제네릭과 extends를 함께 사용해 받는 타입을 제한하면 잘못된 값을 넘길 수 없기 때문에 휴먼 에러를 방지할 수 있다
- extends를 활용해 조건부 타입을 설정하여 반환값을 사용자가 원하는 값으로 구체화 할 수 있다. 이에 따라 불필요한 타입 가드, 타입 단언등을 방지할 수 있다. 


### 5.1.4 infer를 활용하여 타입 추론하기
extends를 사용할때 infer 키워드를 사용할 수 있는데, extends로 조건을 서술하고 infer로 타입을 추론하는 방식을 취한다.
```
type UnpackProimise<T> = T extends Promise<infer K>[] ? K : any;
```
T가 Promise로 래핑된 경우에는 K를 반환하고 그렇지 않은 경우에는 any를 반환한다. 


## 5.2 템플릿 리터럴 타입 활용하기 
템플릿 리터럴 타입을 사용하면 컴파일타임의 변수에 할당되는 타입을 특정 문자열로 정확하게 검사하여 휴먼 에러를 방지할 수 있고, 자동 완성 기능을 통해 생산성을 높일 수 있다.
