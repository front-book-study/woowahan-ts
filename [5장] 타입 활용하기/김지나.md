## 5.1 조건부 타입
### 5.1.1 extends와 제네릭을 활용한 조건부 타입
`extends` 키워드는 타입을 확장할 때와 타입을 조건부로 설정할 때 사용되며, 제네릭 타입에서는 한정자 역할로도 사용된다. 
> T extneds U ? X : Y

```
interface Bank {...}
interface Card {...}

type PayMethod<T> = T extends "card" ? Card : Bank;
type CardPayMethodType = PayMethod<"card">;
type BankPayMethodType = PayMethod<"bank">;

```
### 5.1.2 조건부 타입을 사용하지 않았을 때의 문제점 
// 유니온 값을 반환하는 사례
- 사용자의 의도와는 다르게 정확한 타입을 반환하지 못한다.
- 인자에 따라 반환되는 타입을 다르게 설정하고 싶다면 extends를 사용한 조건부 타입을 활용하면 된다.

### 5.1.3 extends 조건부 타입을 활용하여 개선하기
- 제네릭과 extends를 함께 사용해 받는 타입을 제한하면 잘못된 값을 넘길 수 없기 때문에 휴먼 에러를 방지할 수 있다
- extends를 활용해 조건부 타입을 설정하여 반환값을 사용자가 원하는 값으로 구체화 할 수 있다. 이에 따라 불필요한 타입 가드, 타입 단언등을 방지할 수 있다. 


### 5.1.4 infer를 활용하여 타입 추론하기
extends를 사용할때 infer 키워드를 사용할 수 있는데, extends로 조건을 서술하고 infer로 타입을 추론하는 방식을 취한다.
```
type UnpackProimise<T> = T extends Promise<infer K>[] ? K : any;
```
T가 Promise로 래핑된 경우에는 K를 반환하고 그렇지 않은 경우에는 any를 반환한다. 


## 5.2 템플릿 리터럴 타입 활용하기 
템플릿 리터럴 타입을 사용하면 컴파일타임의 변수에 할당되는 타입을 특정 문자열로 정확하게 검사하여 휴먼 에러를 방지할 수 있고, 자동 완성 기능을 통해 생산성을 높일 수 있다.

## 5.3 커스텀 유틸리티 타입 활용하기
### 5.3.1 유틸리티 함수를 활용해 styled-components의 중복 타입 선언 피하기
```
export type Props = {
  height?: string;
  color?: keyof typeof colors;
  isFull?: boolean;
  className?: string;
};

export const Hr: VFC<Props> = ({ height, color, isFull, className }) => {
  return (
    <HrComponent
      height={height}
      color={color}
      isFull={isFull}
      className={className}
    />
  );
};
```

<Hr/>에 사용된 타입 Props 중 일부분의 타입만을 필요로 하기 때문에 `Pick`을 이용해 필요한 타입만 픽하여 새로 정의할 수 있다.
```
//HrComponent.tsx
type StyledProps = Pick<Props, "height" | "color" | "isFull">;
```
=> 타입 코드의 중복을 줄이고 유지보수에 용이하다.

### 5.3.2 PickOne 유틸리티 함수
타입스크립트에는 서로 다른 2개 이상의 객체를 유니온 타입으로 받을 때 타입 검사가 제대로 진행되지 않는 이슈가 있다. -> 이러한 문제를 해결하기 위해 PickOne이라는 이름의 유틸리티 함수를 사용할 수 있음
```
type Card = {
  card: string;
};
type Account = {
  account: string;
};
function withdraw(type: Card | Account) {
...
}
withdraw({ card: "hyundai", account: "hana" });
// Card와 Account 속성을 한 번에 받아도 에러 없음
```
Card | Account는 합집합이 되어버리기 때문에 타입에러가 발생하지 않는다.

**해결 1 - 식별할 수 있는 유니온으로 객체 타입을 유니온으로 받기**
```
type Card = {
  type: "card"; // 판별자 추가
  card: string;
};
type Account = {
  type: "account"; // 판별자 추가
  account: string;
};
function withdraw(type: Card | Account) {
  /* ... */
}
withdraw({ card: "hyundai", account: "hana" }); 
// 🚨 ERORR : Argument of type '{ card: string; account: string; }' is not assignable to parameter of type 'Card | Account'.
```
하지만 만일 이미 많은걸 구현한 상황이라면 일일히 판별자를 추가해야하는 번거로움이 생긴다. 

**해결2 - PickOne 커스텀 유틸리티 타입 구현하기**
구현하고자 하는 타입 -> account 또는 card 속성 하나만 존재하는 객체를 받는 타입

account일때는 card를 받지 못하고, card일때는 account를 받지 못하게 해야하므로, 하나의 속성이 들어왔을때 다른 타입을 옵션널한 undefined 값으로 지정하는 방법을 생각해 볼 수 있다. 
-> 옵셔널 + undefined로 타입을 지정하면 사용자가 의도적으로 undefined를 주지 않는 이상 원치않는 속성에 값을 넣었을 때 타입에러를 발생시킬 수 있음. 

```
{ account: string; card?: undefined } | {account?: undefined; card: string}
```

```
type PickOne<T> = {
  [P in keyof T] = Record<P, T[P]> & Partial<Record<Exclude<keyof T, P>, undefined>>;
}[keyof T];
```

**PickOne 살펴보기**
1. One<T>
```
type One<T> = { [P in keyof T]: Record<P, T[P]> }[keyof T];
```
1) [P in keyof T]에서는 T는 객체로 가정하기 때문에 P는 T  객체의 키값을 말한다. 
2) Record<P, T[P]>는 P타입을 키로 가지고 value는 P를 키로 둔 T 객체의 값의 레코드 타입을 말한다. 
3) 따라서 { [P in keyof T]: Record<T, T[P]> }에서는 T 객체의 키 모음이고 value는 해당 키의 원본 객체 T를 말한다.
4) 3번의 타입에서 다시 [keyof T]의 키값으로 접근하기 때문에 최종 결과는 전달받은 T와 같다. 


```
type Card = {card: string}
const one: One<Card> = {card: "hyundai";
```

2. ExcludeOne<T>
```
tyep ExcludeOne<T> = { [P in keyof T]: Partial<Record<Exclude<keyof T, P>, undefined>>;
}[keyof T];
```
1) [P in keyof T]에서 T는 객체로 가정하기 때문에 P는 T 객체의 키값을 말한다.
2) Exclude<keyof T, P>는 T객체가 가진 키값에서 P 타입과 일치하는 키값을 제외한다.이 타입을 A라고 하자
3) Record<A, undefined>는 키로 A타입을, 값으로 undefined 타입을 갖는 레코드 타입이다. 즉 전달받은 객체 타입을 모두 { [key]: undefined } 형태로 만든다. 이타입을 B라고 하자. 
4) Partial<B>는 B타입을 옵셔널로 만든다. 따라서 {[key]?: undefined} 와 같다. 
5) 최종적으로 [P in keyof T]로 매핑된 타입에서 동일한 객체의 키값인 [keyof T]로 접근하기 때문에 4번 타입이 반환된다. 

### 5.3.3 NonNullable 타입 검사 함수를 사용하여 간편하게 타입 가드 하기
일반적으로 if문을 사용해서 null 처리 타입가드를 적용하지만, `is` 키워드와 `NonNullable` 타입으로 타입 검사를 위한 유틸 함수를 만들어서 사용할 수 있다.

NonNullable 타입이란
- 타입스크립트에서 제공하는 유틸리티 타입으로 제네릭으로 받는 T가 null 또는 undefined일 대 never도는 T를 반환하는 타입
- NonNullable를 사용하면 null이나 undefined가 아닌 경우를 제외할 수 있다. 
```
  type NonNullable<T> = T extends null | undefined ? never : T;
  ```

## 5.4 불변객체 타입으로 활용하기
### 5.4.1 Atom 컴포넌트에서 theme sytle 객체 활용하기
Atom 단위의 작은 컴포넌트(Button, Header..)는 폰트 크기, 폰트 색상, 배경색상 등 다양한 환경에서 유연하게 사용될 수 있도록 구현되어야 하는데 이러한 설정값은 props로 넘겨주도록 설계한다. 
props로 직접 색상 값을 직접 넘겨줄 수도 있지만 그럴경우 사용자가 모든 색상 값을 인지해야 하고, 변경 사항이 생길때 사용자가 직접 넣은 모든 곳을 찾아야하는 번거로움 이 생긴다.
=> 이러한 문제를 해결하기 위해 theme 객체를 두고 관리한다.

```
const colors = {
  black: "#000000",
  gray: "#222222",
  white: "#FFFFFF",
  mint: "#2AC1BC",
};

const theme = {
  colors: {
    default: colors.gray,
    ...colors,
  },
  backgroundColor: {
    default: colors.white,
    gray: colors.gray,
    mint: colors.mint,
    black: colors.black,
  },
  fontSize: {
    default: "16px",
    small: "14px",
    large: "18px",
  },
};

// 이러한 Theme 객체를 구체화하여 컴포넌트 개선
// 방법 1 : 컴포넌트(ex. Button)에 props로 전달
// 방법 2 : 컴포넌트가 theme 객체에서 값을 가져와 사용

// before
interface Props {
  fontSize?: string;
  backgroundColor?: string;
  color?: string;
  onClick: (event: React.MouseEvent<HTMLButtonElement>) => void | Promise<void>;
}

// after
// theme 객체 타입 구체화 진행 (typeof + keyof)
type ColorType = typeof keyof theme.colors; // "default" | "black" | "gray" | "white" | "mint"
type BackgroundColorType = typeof keyof theme.backgroundColor; // "default" | "gray" | "mint" | "black"
type FontSizeType = typeof keyof theme.fontSize; // "default" | "small" | "large"

interface Props {
  fontSize?: ColorType; // 👈
  backgroundColor?: BackgroundColorType; // 👈
  color?: FontSizeType; // 👈
  onClick: (event: React.MouseEvent<HTMLButtonElement>) => void | Promise<void>;
}
```

윙하 같이 theme 객체 타입을 구체화하여 타입을 설정하면 지정된 값만을 받을 숭 ㅣㅆ어 자동완성과 다른 값을 넣었을때 타입 오류도 발생하게 할 수 있다.


## 5.5 Record 원시 타입 키 개선하기
객체 선언 시 키가 어떤 값인지 명확하지 않다면 string이나 number같은 원시타입으로 명시하게 되는데 -> 이는 곧 런타임 에러로 이어질 수 있다. 
### 5.5.1 무한한 키를 집합으로 가지는 Record
```
type Category = string;
interface Food {
  name: string;
  // ...
}
const foodByCategory: Record<Category, Food[]> = {
  한식: [{ name: "제육덮밥" }, { name: "뚝배기 불고기" }],
  일식: [{ name: "초밥" }, { name: "텐동" }],
};
```
객체가 Category(string)을 키로 사용하기 때문에 foodByCategory 객체는 무한한 키 집합을 가지게 된다. 이때 foodByCategory 객체에 없는 키값을 사용하더라도 타입스크립트는 오류를 표시하지 않는다.  -> 런타임에서 undefined가 되어 오류를 반환
```
// 문제상황 
oodByCategory["양식"]; // Food[]로 추론
console.log(foodByCategory["양식"]); // ? undefined
foodByCategory["양식"].map((food) => console.log(food.name)); // 🚨 runTime ERROR : Cannot read properties of undefined (reading ‘map’)

// 해결
foodByCategory["양식"]?.map((food) => console.log(food.name)); // ✅
```
이때 옵셔널  체이닝 등을 사용해 런타임 에러를 방지할 수 있다. 
하지만 이 방법도 undefined인지 매번 판단해야 한다는 번거로움이 생긴다. 

### 5.5.2 유닛 타입으로 변경하기
```
// before
type Category = string;

// after
type Category = "한식" | "일식";
```
위와 같이 유닛타입을 활용하면 개ㅑ발 중에 유효하지 않은 키가 사용되었는지를 확인할 수 있다.
하지만 키가 무한해야 하는 상황에서는 적합하지 않다. 


### 5.5.3 Partial을 활용하여 정확한 타입 표현하기
키가 무한한 상황에서는 Partial을 사용하여 해당 값이 undefined일 수 있는 상태임을 표현할 수 있다. 객체 값이 undefined일 수 있는 경우에 Partial을 사영해서 PartialRecord타입을 선언하고 객체를 선언할때 활용할 수 있다.
```
type PartialRecord<K extends string, T> = Partial<Record<K, T>>;
// before
const foodByCategory: Record<Category, Food[]> = {
  한식: [{ name: "제육덮밥" }, { name: "뚝배기 불고기" }],
  일식: [{ name: "초밥" }, { name: "텐동" }],
};

foodByCategory["양식"]; // Food[]로 추론

// after 
const foodByCategory: PartialRecord<Category, Food[]> = {
  한식: [{ name: "제육덮밥" }, { name: "뚝배기 불고기" }],
  일식: [{ name: "초밥" }, { name: "텐동" }],
};

foodByCategory["양식"]; // Food[] 또는 undefined 타입으로 추론
```


