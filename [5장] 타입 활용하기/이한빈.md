# `5.1` 조건부 타입

- 타입스크립트의 조건부 타입은 자바스크립트의 삼항 연산자와 동일
- `Condition ? A : B` 형태
- A는 Condition이 true일 때 도출되는 타입
- B는 false일 때 도출되는 타입

## 1. extends와 제네릭을 활용한 조건부 타입

> `T extends U ? X : Y`<br>= T를 U에 할당할 수 있으면 X 타입, 아니면 Y 타입

조건부 타입에서 extends 사용할 때는 자바스크립트 삼항 연산자와 함께 씀.

```ts
interface Bank {
  // 계좌를 이용한 결제 수단 정보
  financialCode: string;
  companyName: string;
  name: string;
  fullName: string; // 은행 전체 이름
}

interface Card {
  // 카드를 이용한 결제 수단 정보
  financialCode: string;
  companyName: string;
  name: string;
  appCardType?: string; // 카드사 앱을 사용해서 카드 정보 등록할 수 있는지 구별하는 속성
}

type PayMethod<T> = T extends "card" ? Card : Bank;
type CardPayMethodType = PayMethod<"card">;
type BankPayMethodType = PayMethod<"bank">;
```

제네릭 매개변수(`<T>`)에 "card"가 들어오면 Card 타입, 그 외의 값이 들어오면 Bank 타입

<br>

## 2. 조건부 타입을 사용하지 않았을 때 문제점

#### react-query(리액트 쿼리) 활용 예시

> 계좌, 카드, 앱 카드 등 3가지 결제 수단 정보를 가져오는 API의 엔드포인트<br><br>계좌 정보 엔드포인트: www.baemin.com/baeminpay/.../bank<br>카드 정보 엔드포인트: www.baemin.com/baeminpay/.../card<br>앱 카드 정보 엔드포인트: www.baemin.com/baeminpay/.../appcard

각 API는 계좌, 카드, 앱카드의 결제 수단 정보를 배열 형태로 반환

(추가 공부 중..)

<br>

## 3. extends 조건부 타입을 활용하여 개선하기

> 앞 챕터와 함께 추가적으로 공부해서 다시 정리해서 올리도록 하겠습니다..!!!

<br>

## 4. infer를 활용해서 타입 추론하기

> '추론하다'라는 의미를 지닌 infer 키워드를 통해 타입을 추론할 수 있음

```ts
type UnpackPromise<T> = T extends Promise<infer K>[] ? K : any;
```

UnpackPromise 타입은 제네릭으로 T를 받아 T가 Promise로 래핑된 경우라면 K를 반환, 그렇지 않으면 any 반환
`Promise<infer K>` = Promise의 반환 값을 추론해 해당 값의 타입을 K로 한다는 의미

<br>
<br>
<br>

# `5.2` 템플릿 리터럴 타입 활용하기

```ts
type HeaderTag = "h1" | "h2" | "h3" | "h4";
```

유니온 타입을 사용해 변수 타입을 특정 문자열로 지정

이 기능을 통해

- 컴파일 타임의 변수에 할당되는 타입을 특정 문자열로 정확히 검사하여 휴먼 에러 방지 가능
- 자동 완성 기능을 통해 개발 생산성 ↑

```ts
type HeadingNumber = 1 | 2 | 3 | 4;
type HeaderTag = `h${HeadingNumber}`;
```

#### 주의할 점❗

타입스크립트 컴파일러가 유니온 추론할 때 **시간이 오래 걸리면 비효율적** → 타입스크립트가 타입을 추론하지 않고 에러를 내뱉을 때가 있음

따라서 유니온 조합의 경우의 수가 너무 많지 않게 **적절하게 나누어 타입을 정의**하는 게 좋다.
