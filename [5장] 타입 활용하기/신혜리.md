## 5.1] 조건부 타입

---

### 1. extends와 제네릭을 활용한 조건부 타입

extends는 타입을 확장할때 / 타입을 조건부로 설정할 때 / 제네릭 타입에서는 한정자 역할로 사용됨

```tsx
T extends U ? X : Y
// T를 U에 할당할 수 있으면 X 타입, 아니면 Y 타입

interface Bank { 
 financialCode: string;
 companyName: string;
 name: string;
 fullName: string;
}

interface Card {
 financialCode: string;
 companyName: string;
 name: string;
 appCardType?: string;
}

type PayMethod<T> = T extends 'card' ? Card : Bank;
type CardPayMethodType = PayMethod<'card'>
type BankPayMethodType = PayMethod<'bank'>
```

### 2. 조건부 타입을 사용하지 않았을 때의 문제점

`제공된 예시 분석`

- 의도한 결과 :
    - useGetRegisteredList 는 param으로 넘긴 type에 따라서 api 호출을 하고
    - 그 결과값을 리턴하며 그 결과값은 type 파라미터에 대응되는 타입이다
    - type card / appcard = > Card
    - type bank ⇒ Bank
- 문제점 :
    - 리턴타입이 모두 PayMethodType[] 이다.
    - type 파라미터에 card, appcard, bank 어떤 값을 넣든 리턴 타입 같아서 구별하기 힘들다.
- 문제점의 원인 :
    - PayMethodType은 PayMethodInfo<Card> 와 PayMethodInfo<Bank> 의 유니온으로 설정되어있기 때문이다.
    - type 파라미터에 따라서 둘 중 어떤 타입의 결과값인지 타입스크립트는 알 수 없다.

<aside>
💡

153p 하단에 문제점에 대한 서술을 하면서 PocketInfo 타입에 대한 설명을 한다. 이 부분이 이해가 안간다…

</aside>

### 3. extends 조건부 타입을 활용하여 개선하기

`위의 예시를 해결하는 방법`

- 제네릭 유니온으로 해결한다.
- 기존에 파라미터로 넘겨줬던 type을 제네릭으로 넘겨주고 이를 바탕으로 타입을 조건부로 Card, Bank를 리턴한다.
- 결과적으로 card, appCard ⇒ Card[] / bank ⇒ Bank[] 를 리턴한다.

```tsx
type PayMethodType<T extends 'card' | 'appcard' | 'bank'> = T extends
  | 'card'
  | 'appcard'
  ? Card
  : Bank;
```

### 4. infer를 활용해서 타입 추론하기

```tsx
type UnpackMenuNames<T extends ReadonlyArray<MenuItem>> = T extends
  ReadonlyArray<infer U>
    ? U extends MainMenu
      ? U['subMenus'] extends infer V
        ? V extends ReadonlyArray<SubMenu>
          ? UnpackMenuNames<V>
          : U['name']
        : never
      : U extends SubMenu
      ? U['name']
      : never
    : never;
    

export type PermissionNames = UnpackMenuNames<typeof menuList>; 
// [기기 내역 관리, 헬멧 인증 관리, 운행 관리]
```

- menuList ⇒ as const이기 때문에 ReadonlyArray<MenuItem> 타입이다.
- T extends ReadonlyArray<infer U> ⇒ `U = MenuItem` 임을 알 수 있다.
- U extend MainMenu
    - MenuItem은 MainMenu | SubMenu 이기 때문에 분기처리한다.
    - true : U extends MainMenu
        - MainMenu[’subMenus’] 가 있으면 그 타입은 SubMenu[] ⇒ `V = SubMenu[]`
        - V extends ReadonlyArray<SubMenu> ⇒ `V = SubMenu[]`
        - true :
        - false
    - false :  U extends SubMenu
        - true :
        - false : never → 해당 경우의 수는 없다.

## 5.2] 템플릿 리터럴 타입 활용하기

---

- 4.1 에 등장한 타입
- 자바스크립트 템플릿 리터럴 문법을 사용해서 특정 문자열에 대한 타입을 선언할 수 있음
- 주의) 템플릿 리터럴로 여러개 조합을 많이 만드는 경우 타입스크립트 컴파일러가 유니온을 추론하는데 시간이 오래걸려서 타입을 추론하지 않고 에러를 내뱉을 때가 있음.

```jsx
type HeadingNumber = 1 | 2 | 3 | 4 | 5;
type HeaderTag = `h${HeadingNumber}`;
```

```jsx
type Vertical = 'top' | 'bottom';
type Horizon = 'left' | 'right';

type Direction = Vertical | `${Vertical}${Capitalize<Horizon>}`;
// Captialize : 앞글자만 대문자로 바꿔주는 utility type 
```

https://toss.tech/article/template-literal-types