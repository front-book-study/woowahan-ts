### Pick
1. **명시적 의도 표현**

```tsx
// Pick: "styled-components에서 이 3개 속성만 사용한다"
type StyledProps = Pick<Props, "height" | "color" | "isFull">;

// Omit: "className만 빼고 나머지 다 사용한다"
type StyledProps = Omit<Props, 'className'>;

```

Pick을 사용하면 **실제로 styled-components에서 사용되는 속성들**을 명확히 보여줍니다.

**유지보수성과 명시성** 측면

1. **확장성 고려**


```tsx
export type Props = {
  height?: string;
  color?: keyof typeof colors;
  isFull?: boolean;
  className?: string;
  onClick?: () => void;      // 새로 추가
  'data-testid'?: string;    // 새로 추가
  ...
}

```

- **Pick 사용 시**: StyledProps는 여전히 3개 속성만 포함 ✅
- **Omit 사용 시**: StyledProps에 `onClick`, `data-testid`도 포함되어 불필요한 속성이 styled-components로 전달됨 ❌

### PickOne

식별할 수 있는 유니온을 대체가능한 유틸리티 타입

식별할 수 있는 유니온의 문제점

이미 구현된 상태에서 식별할 수 있는 유니온을 적용해야한다면, 해당 함수를 사용하는 부분을 모두 수정해야함

**배경**

`{ account: string} | {card: string}` 일 때 account와 card 속성을 모두 가진 객체도 허용됨

**구현 원리**

account일 때 card를 받지못하고, card일 때 account를 받지 못하게 하려면 하나의 속성이 들어왔을 때 다른 타입을 옵셔널한 undefined 값으로 지정하는 방법이 있음

옵셔널 + undefined로 타입 지정 시 사용자가 의도적으로 undefined 값을 넣지 않는 이상, 원치 않는 속성에 값을 넣었을 때 타입에러가 발생할 것

```tsx
{ account: string; card?: undefined } | { account?: undefined; card: string }
```

### NonNullable

```tsx
function NonNullable<T>(value: T): value is NonNullable<T> {
  return value !== null && value !== undefined;
}
```

`null` 또는 `undefined`를 검사해주는 타입가드 함수를 만들 수 있다

사용 예시

```tsx
const shopList = [
  { shopNo: 100, category: "chicken" },
  { shopNo: 101, category: "pizza" },
  { shopNo: 102, category: "noodle" },
];

const shopAdCampaignList = await Promise.all(shopList.map((shop)=> AdCampaignAPI.operating(shop.shopNo)));
  
const shopAds = shopAdCampaignList.filter(NonNullable);
```

### keyof, typeof 활용하기

```tsx
const colors = {
  black: "#000000",
  gray: "#222222",
  white: "#FFFFFF",
  mint: "#2AC1BC",
};

const theme = {
  colors: {
    default: colors.gray,
    ...colors
  },
  backgroundColors: {
    default: colors.white,
    gray: colors.gray,
    mint: colors.mint,
    black: colors.black,
  },
  fontSize: {
    default: "16px",
    small: "14px",
    large: "18px",
  },
};

type ColorType = keyof typeof theme.colors;
type BackgroundColorType = keyof typeof theme.backgroundColors;
type FontSizeType = keyof typeof theme.fontSize;

interface Props {
  color?: ColorType;
  backgroundColor?: BackgroundColorType;
  fontSize?: FontSizeType;
  children?: React.ReactNode;
  onClick: (event: React.MouseEvent<HTMLButtonElement>) => void | Promise<void>;
}
```

### 객체 선언 시 키가 어떤 값인지 명확하지 않을 때 Record를 명시적으로 사용하는 방안

> ❌ 명시적으로 사용하지 않은 경우
> 

**무한한 키를 집합으로 가지는 Record**

```tsx
type Category = string;
interface Food {
  name: string;
  // ...
}
const foodByCategory: Record<Category, Food[]> = {
  한식: [{ name: "제육덮밥" }, { name: "뚝배기 불고기" }],
  일식: [{ name: "초밥" }, { name: "텐동" }],
};

foodByCategory["양식"]; // Food[]로 추론
foodByCategory["양식"].map((food) => console.log(food.name)); // 오류가 발생하지 않는다

foodByCategory["양식"].map((food) => console.log(food.name)); // Uncaught TypeError: Cannot read properties of undefined (reading ‘map’)

foodByCategory["양식"]?.map((food) => console.log(food.name));  // 옵셔널체이닝으로 런타임 에러 방지
```

문제점

- 어떤 값이 `undefined` 인지 매번 판단해야함
- 실수로 undefined일 수 잇는 값을 인지하지 못하고 코드 작성 시 런타임 에러

> ✅ 명시적으로 사용
> 

**유닛 타입으로 변경하기**

```tsx
type Category = "한식" | "일식";
interface Food {
	name: string;
	// ...
}
const foodByCategory: Record<Category, Food[]> = {
  한식: [{ name: "제육덮밥" }, { name: "뚝배기 불고기" }],
  일식: [{ name: "초밥" }, { name: "텐동" }],
};

// Property ‘양식’ does not exist on type ‘Record<Category, Food[]>’.
foodByCategory["양식"];
```

**Partial을 활용하여 정확한 타입 표현하기**
```tsx
type PartialRecord<K extends string, T> = Partial<Record<K,T>>;
type Category = string;

interface Food {
  name: string;
  // ...
}

const foodByCategory: PartialRecord<Category, Food[]> = {
  한식: [{ name: "제육덮밥" }, { name: "뚝배기 불고기" }],
  일식: [{ name: "초밥" }, { name: "텐동" }],
};
  
foodByCategory["양식"]; // Food[] 또는 undefined 타입으로 추론
foodByCategory["양식"].map((food) => console.log(food.name)); // Object is possibly 'undefined'
foodByCategory["양식"]?.map((food) => console.log(food.name)); // OK
```
