## 3.1 ] 타입스크립트만의 독자적 타입 시스템

---

![ts 계층구조.png](attachment:2de3a8dd-b33a-43ee-8150-ba504a42166c:ts_계층구조.png)

javascript에는 어디서도 any라는 타입을 찾을 수 없다. any라는 타입은 타입스크립트에 존재하는 타입이기 때문이다. 하지만, any라는 타입은 자바스크립트의 동작 방식과 일치한다.

### any

- any로 지정한 타입에는 어떤값을 할당하더라도 오류 발생하지 않음 (never 제외)
- 타입스크립트의 정적 타이핑을 무효화 = 자바스크립트의 동적 타이핑과 동일
  - 일반 자바스크립트와 동일 (정적타이핑)
  - 타입스크립트에서 타입을 명시하지 않음과 동일.
- 결론적으로 any 쓰는 것을 지양해야함.
- tsconfig.json 에서 noImplicityAny 옵션을 활성화하면 any 타입에 대한 경고를 발생시킬 수 있음.
- any를 사용하는 대표 사례
  - 개발 단계에서 임시로 값을 지정할 때 : 빠른 개발을 위한 임시 any 사용
  - 어떤 값의 타입을 명확하게 지정하기 어려울 때 : 다양한 값이 들어올 수 있어서 개별적인 타입을 모두 지정해주기 힘들 때 범용성을 위해 any 사용
  - 값을 예측할 수 없을 때 : response.json() 처럼 반환되는 값을 예측할 수 없어 any 사용
  ⇒ 하지만, 어떤 상황에도 any 사용 지양 권고
  ⇒ 런타임에 에러가 발생할 가능성이 높아짐 / 온전히 컨트롤할 수 없음

### unknown

- any 타입과 똑같이 모든 타입(never 제외)의 값을 할당할 수 있음.
  ```tsx
  let unknownValue: unknown;

  unknownValue = 1004;
  unknownValue = 'hi';
  unknownValue = () => console.log('hi');
  ```
- 하지만, any 외에 다른 타입으로 선언된 변수에 unknown 타입 값을 할당할 수 없음
  ```tsx
  let someValue1: any = unknownValue; // O
  let someValue2: number = unknownValue; // X
  let someValue3: string = unknownValue; // X
  ```
- unknown 타입이 추가된 이유는
  - 할당은 자유롭게 : 어떤 값이 들어올지 모르기 때문에 범용성있게 값을 받게 하기 위해
  - BUT 사용할때는 타입을 명확하게 좁히고 사용하게 하기 위함 : 엄격한 타입 검사를 강제해서 타입이 명확하게 식별된 이후에 사용하게 하기 위해
- as unknown as Type : any와 별다를바가 없다…?

### void

- 함수가 반환값이 없는 경우 void 사용
  - return문이 따로 없으면 타입스크립트 컴파일러가 자동적으로 반환값으로 void로 추론
  - 함수 자체를 다른 함수의 인자로 전달하는 경우에만 주로 사용
- 함수가 안니 변수에도 void를 사용할 수 있지만 무의미
  - void 타입의 변수에는 null, undefined만 할당가능
  - tsconfig에서 strictNullChecks : true 로 설정하면 undefined만 할당가능 (null은 불가)

### never

- 함수에서 값을 반환할 수 없을 때 사용
  - 함수의 반환값이 없는 것 = void / 반환할 수 없는 것 = never 은 구별됨.
  - 에러를 던지는 경우 : throw new Error(’’) 는 값을 반환한 것으로 간주하지 않음
  - 무한 루프 함수인 경우 : 함수가 종료되지 않아서 값을 반환하지 못함.
- never을 제외한 어떠한 타입도 never 타입에 할당될 수 없음 (any 포함)
- 조건부 타입 결정할때 특정 조건 만족하지 않는 경우 엄격한 타입 검사 목적으로 never 타입 명시적으로 사용

### Array

- 자바스크립트 배열에는 자료형에 상관없이 모든 타입의 원소들을 넣을 수 있음
- 타입스크립트에서는 좀 더 엄격히 타입을 제한할 수 있음
  - 단일 타입 : number[] / Array<number> 방식으로 선언할 수 있음
  - 복수 타입 : number[] | string [] / (number | string)[] / Array<number | string> 방식으로 선언할 수 있음

### Tuple

- 배열의 하위 타입. 배열 기능에 길이 제한까지 추가한 타입 시스템
- [string, number, number?, …string[]] 방식으로 선언할 수 있음.
- 옵셔널 속성은 ?를 뒤에 붙여주면 됨. 사용할때는 undefined를 넣어주면 됨.
- 리액트의 useState의 반환값도 튜플
- 배열 원소 자리마다 명확한 의미 부여
- 사용자 입장에서 각 자리마다 유연한 이름을 설정할 수 있음

```tsx
type Example = [string, number, number?, ...string[]];

const a: Example = ['name', 1];                     // ✅ OK
const b: Example = ['name', 1, 2];                  // ✅ OK
const c: Example = ['name', 1, 2, 'tag1', 'tag2'];  // ✅ OK
const d: Example = ['name', 1, **undefined**, 'tag1'];  // ✅ OK
const e: Example = ['name', 1, 'tag1'];             // ❌ Error! 'tag1'은 세 번째에 올 수 없음
```

### enum

- 타입스크립트에서 지원하는 특수 타입으로 열거형에 쓰임
- 컴파일 타임에는 타입으로 런타임에는 객체로 쓰임
  - 런타임에 객체로 쓰이기 위해서 컴파일 후에도 객체로 살아있다는 의미.
- 객체와 비슷하게 key, value로 구성되며 value는 선택

  - key는 문자열만 가능
  - value는 문자열, 숫자, 숫자/문자열로 계산 가능한 식만 가능
  - value가 별도로 지정되지 않은 경우 0부터 시작하여 자동추론
  - 만약 그 전 key의 value가 문자열인 경우 다음 value도 문자열이여야함.
    → 아니면 추론 불가능해서 에러발생

  ```tsx
  enum ProgrammingLanguage {
    Typescript = 'TypeScript',
    Javascript = 'JavaScript',
    Java, //error -> 자동추론 불가
    Python = 'Python',
    Kotlin, //error -> 자동추론 불가
    Rust = 300,
    Go, // 301 자동추론 가능
  }
  ```

- **Number Enum**
  - value가 숫자인 enum (value가 자동추론되는 것도 포함)
  - 양방향 매핑 지원 : key, value 모두로 접근 가능한 방식
    - **존재하지 않는 key, value 접근시 error가 아닌 undefined 반환함에 주의**
    - 컴파일 단계에서 **자바스크립트 객체로 컴파일** 되기 때문에 dot & bracket 으로 둘 다 접근 가능
    ```tsx
    enum ProgrammingLanguage {
      Typescript,  // 0
      Javascript,  // 1
      Java,        // 2
      Python,      // 3
      Kotlin,      // 4
      Rust,        // 5
      Go.          // 6
    }

    // key로 접근
    ProgrammingLanguage.Typescript; // 0
    ProgrammingLanguage['Rust']; // 5
    ProgrammingLanguage['C#']; // undefined (notError)

    // value로 접근
    ProgrammingLanguage[0]; // "Typescript"
    ProgrammingLanguage[999]; // undefined (notError)
    ```
    ```tsx
    var ProgrammingLanguage;
    (function (ProgrammingLanguage) {
        ProgrammingLanguage[ProgrammingLanguage["Typescript"] = 0] = "Typescript";
        ProgrammingLanguage[ProgrammingLanguage["Javascript"] = 1] = "Javascript";
        ProgrammingLanguage[ProgrammingLanguage["Java"] = 2] = "Java";
        ProgrammingLanguage[ProgrammingLanguage["Python"] = 3] = "Python";
        ProgrammingLanguage[ProgrammingLanguage["Kotlin"] = 4] = "Kotlin";
        ProgrammingLanguage[ProgrammingLanguage["Rust"] = 5] = "Rust";
        ProgrammingLanguage[ProgrammingLanguage["Go"] = 6] = "Go";
    })(ProgrammingLanguage || (ProgrammingLanguage = {}));

    // 위와 같이 javascript로 컴파일 됨.
    ProgrammingLanguage['Typescript'] → "*TypeScript*"
    ProgrammingLanguage.Python. → "*Python*"
    ProgrammingLanguage[0] → "*TypeScript*"
    ```
- **String Enum**

  - value가 문자열인 enum
  - 단방향 매핑만 지원 : key로만 접근가능. value로는 접근 불가 (역매핑 X)
    - **존재하지 않는 key로 접근시 error가 아닌 undefined 반환함에 주의**
    - 문자열 enum은 역매핑 객체를 생성하지 않으므로 숫자 인덱스나 값으로 역조회 불가
    ```tsx
    enum ProgrammingLanguage {
      Typescript = '타입스크립트',
      Javascript = '자바스크립트',
      Python = '파이썬',
    }

    // key로 접근
    ProgrammingLanguage.Typescript; // '타입스크립트' (O)
    ProgrammingLanguage['Python']; // '파이썬' (O)
    ProgrammingLanguage['Rust']; // undefined (Error가 아님에 주의)

    // value로 접근 (역매핑)
    ProgrammingLanguage['타입스크립트']; // undefined (Error가 아님에 유의)
    ```
    ```tsx
    var ProgrammingLanguage;
    (function (ProgrammingLanguage) {
        ProgrammingLanguage["Typescript"] = "타입스크립트";
        ProgrammingLanguage["Javascript"] = "자바스크립트";
        ProgrammingLanguage["Python"] = "파이썬";
    })(ProgrammingLanguage || (ProgrammingLanguage = {}));

    // 위와 같이 javascript로 컴파일 됨.
    ProgrammingLanguage['Typescript'] → "*TypeScript*"
    ProgrammingLanguage["타입스크립트"] → undefined (Error가 아님에 유의)
    ProgrammingLanguage[0] → undefined (Error가 아님에 유의)

    => [결론] 문자열 enum은 역매핑 객체를 생성하지 않기 때문에 숫자 인덱스나 값으로 역조회가 안됨.
    ```

- 장점 : 일반 문자열보다 타입 안정성이 우수
- 단점 : 존재하지 않는 속성에 접근하더라도 에러가 발생하지 않고 undefined 반환
  - **tsconfig에 어떤 옵션을 설정하더라도 이를 보완할 수 없음**
