## 3.1 ] 타입스크립트만의 독자적 타입 시스템

---

![ts 계층구조.png](attachment:2de3a8dd-b33a-43ee-8150-ba504a42166c:ts_계층구조.png)

javascript에는 어디서도 any라는 타입을 찾을 수 없다. any라는 타입은 타입스크립트에 존재하는 타입이기 때문이다. 하지만, any라는 타입은 자바스크립트의 동작 방식과 일치한다.

### any

- any로 지정한 타입에는 어떤값을 할당하더라도 오류 발생하지 않음 (never 제외)
- 타입스크립트의 정적 타이핑을 무효화 = 자바스크립트의 동적 타이핑과 동일
  - 일반 자바스크립트와 동일 (정적타이핑)
  - 타입스크립트에서 타입을 명시하지 않음과 동일.
- 결론적으로 any 쓰는 것을 지양해야함.
- tsconfig.json 에서 noImplicityAny 옵션을 활성화하면 any 타입에 대한 경고를 발생시킬 수 있음.
- any를 사용하는 대표 사례
  - 개발 단계에서 임시로 값을 지정할 때 : 빠른 개발을 위한 임시 any 사용
  - 어떤 값의 타입을 명확하게 지정하기 어려울 때 : 다양한 값이 들어올 수 있어서 개별적인 타입을 모두 지정해주기 힘들 때 범용성을 위해 any 사용
  - 값을 예측할 수 없을 때 : response.json() 처럼 반환되는 값을 예측할 수 없어 any 사용
  ⇒ 하지만, 어떤 상황에도 any 사용 지양 권고
  ⇒ 런타임에 에러가 발생할 가능성이 높아짐 / 온전히 컨트롤할 수 없음

### unknown

- any 타입과 똑같이 모든 타입(never 제외)의 값을 할당할 수 있음.
  ```tsx
  let unknownValue: unknown;

  unknownValue = 1004;
  unknownValue = 'hi';
  unknownValue = () => console.log('hi');
  ```
- 하지만, any 외에 다른 타입으로 선언된 변수에 unknown 타입 값을 할당할 수 없음
  ```tsx
  let someValue1: any = unknownValue; // O
  let someValue2: number = unknownValue; // X
  let someValue3: string = unknownValue; // X
  ```
- unknown 타입이 추가된 이유는
  - 할당은 자유롭게 : 어떤 값이 들어올지 모르기 때문에 범용성있게 값을 받게 하기 위해
  - BUT 사용할때는 타입을 명확하게 좁히고 사용하게 하기 위함 : 엄격한 타입 검사를 강제해서 타입이 명확하게 식별된 이후에 사용하게 하기 위해
- as unknown as Type : any와 별다를바가 없다…?

### void

- 함수가 반환값이 없는 경우 void 사용
  - return문이 따로 없으면 타입스크립트 컴파일러가 자동적으로 반환값으로 void로 추론
  - 함수 자체를 다른 함수의 인자로 전달하는 경우에만 주로 사용
- 함수가 안니 변수에도 void를 사용할 수 있지만 무의미
  - void 타입의 변수에는 null, undefined만 할당가능
  - tsconfig에서 strictNullChecks : true 로 설정하면 undefined만 할당가능 (null은 불가)

### never

- 함수에서 값을 반환할 수 없을 때 사용
  - 함수의 반환값이 없는 것 = void / 반환할 수 없는 것 = never 은 구별됨.
  - 에러를 던지는 경우 : throw new Error(’’) 는 값을 반환한 것으로 간주하지 않음
  - 무한 루프 함수인 경우 : 함수가 종료되지 않아서 값을 반환하지 못함.
- never을 제외한 어떠한 타입도 never 타입에 할당될 수 없음 (any 포함)
- 조건부 타입 결정할때 특정 조건 만족하지 않는 경우 엄격한 타입 검사 목적으로 never 타입 명시적으로 사용

### Array

- 자바스크립트 배열에는 자료형에 상관없이 모든 타입의 원소들을 넣을 수 있음
- 타입스크립트에서는 좀 더 엄격히 타입을 제한할 수 있음
  - 단일 타입 : number[] / Array<number> 방식으로 선언할 수 있음
  - 복수 타입 : number[] | string [] / (number | string)[] / Array<number | string> 방식으로 선언할 수 있음

### Tuple

- 배열의 하위 타입. 배열 기능에 길이 제한까지 추가한 타입 시스템
- [string, number, number?, …string[]] 방식으로 선언할 수 있음.
- 옵셔널 속성은 ?를 뒤에 붙여주면 됨. 사용할때는 undefined를 넣어주면 됨.
- 리액트의 useState의 반환값도 튜플
- 배열 원소 자리마다 명확한 의미 부여
- 사용자 입장에서 각 자리마다 유연한 이름을 설정할 수 있음

```tsx
type Example = [string, number, number?, ...string[]];

const a: Example = ['name', 1];                     // ✅ OK
const b: Example = ['name', 1, 2];                  // ✅ OK
const c: Example = ['name', 1, 2, 'tag1', 'tag2'];  // ✅ OK
const d: Example = ['name', 1, **undefined**, 'tag1'];  // ✅ OK
const e: Example = ['name', 1, 'tag1'];             // ❌ Error! 'tag1'은 세 번째에 올 수 없음
```

### enum

- 타입스크립트에서 지원하는 특수 타입으로 열거형에 쓰임
- **컴파일 타임에는 타입으로 런타임에는 객체로 쓰임**
  - **런타임에 객체로 쓰이기 위해서 컴파일 후에도 객체로 살아있다는 의미.**
  - **컴파일 이후에 즉시실행함수로 자바스크립트 객체가 됨.**
- 객체와 비슷하게 key, value로 구성되며 value는 선택

  - key는 문자열만 가능
  - value는 문자열 (String Enum) , 숫자 (Number Enum), 숫자/문자열로 계산 가능한 식만 가능
  - value가 별도로 지정되지 않은 경우 0부터 시작하여 자동추론
  - 만약 그 전 key의 value가 문자열인 경우 다음 value도 문자열이여야함.
    → 아니면 추론 불가능해서 에러발생

  ```tsx
  enum ProgrammingLanguage {
    Typescript = 'TypeScript',
    Javascript = 'JavaScript',
    Java, //error -> 자동추론 불가
    Python = 'Python',
    Kotlin, //error -> 자동추론 불가
    Rust = 300,
    Go, // 301 자동추론 가능
  }
  ```

- **Number Enum**
  - value가 숫자인 enum (value가 자동추론되는 것도 포함)
  - 양방향 매핑 지원 : key, value 모두로 접근 가능한 방식
    - **존재하지 않는 key, value 접근시 error가 아닌 undefined 반환함에 주의**
    - 컴파일 단계에서 **자바스크립트 객체로 컴파일** 되기 때문에 dot & bracket 으로 둘 다 접근 가능
    ```tsx
    enum ProgrammingLanguage {
      Typescript,  // 0
      Javascript,  // 1
      Java,        // 2
      Python,      // 3
      Kotlin,      // 4
      Rust,        // 5
      Go.          // 6
    }

    // key로 접근
    ProgrammingLanguage.Typescript; // 0
    ProgrammingLanguage['Rust']; // 5
    ProgrammingLanguage['C#']; // undefined (notError)

    // value로 접근
    ProgrammingLanguage[0]; // "Typescript"
    ProgrammingLanguage[999]; // undefined (notError)
    ```
    ```tsx
    var ProgrammingLanguage;
    (function (ProgrammingLanguage) {
        ProgrammingLanguage[ProgrammingLanguage["Typescript"] = 0] = "Typescript";
        ProgrammingLanguage[ProgrammingLanguage["Javascript"] = 1] = "Javascript";
        ProgrammingLanguage[ProgrammingLanguage["Java"] = 2] = "Java";
        ProgrammingLanguage[ProgrammingLanguage["Python"] = 3] = "Python";
        ProgrammingLanguage[ProgrammingLanguage["Kotlin"] = 4] = "Kotlin";
        ProgrammingLanguage[ProgrammingLanguage["Rust"] = 5] = "Rust";
        ProgrammingLanguage[ProgrammingLanguage["Go"] = 6] = "Go";
    })(ProgrammingLanguage || (ProgrammingLanguage = {}));

    // 위와 같이 javascript로 컴파일 됨.
    ProgrammingLanguage['Typescript'] → "*TypeScript*"
    ProgrammingLanguage.Python. → "*Python*"
    ProgrammingLanguage[0] → "*TypeScript*"
    ```
- **String Enum**

  - value가 문자열인 enum
  - 단방향 매핑만 지원 : key로만 접근가능. value로는 접근 불가 (역매핑 X)
    - **존재하지 않는 key로 접근시 error가 아닌 undefined 반환함에 주의**
    - 문자열 enum은 역매핑 객체를 생성하지 않으므로 숫자 인덱스나 값으로 역조회 불가
    ```tsx
    enum ProgrammingLanguage {
      Typescript = '타입스크립트',
      Javascript = '자바스크립트',
      Python = '파이썬',
    }

    // key로 접근
    ProgrammingLanguage.Typescript; // '타입스크립트' (O)
    ProgrammingLanguage['Python']; // '파이썬' (O)
    ProgrammingLanguage['Rust']; // undefined (Error가 아님에 주의)

    // value로 접근 (역매핑)
    ProgrammingLanguage['타입스크립트']; // undefined (Error가 아님에 유의)
    ```
    ```tsx
    var ProgrammingLanguage;
    (function (ProgrammingLanguage) {
        ProgrammingLanguage["Typescript"] = "타입스크립트";
        ProgrammingLanguage["Javascript"] = "자바스크립트";
        ProgrammingLanguage["Python"] = "파이썬";
    })(ProgrammingLanguage || (ProgrammingLanguage = {}));

    // 위와 같이 javascript로 컴파일 됨.
    ProgrammingLanguage['Typescript'] → "*TypeScript*"
    ProgrammingLanguage["타입스크립트"] → undefined (Error가 아님에 유의)
    ProgrammingLanguage[0] → undefined (Error가 아님에 유의)

    => [결론] 문자열 enum은 역매핑 객체를 생성하지 않기 때문에 숫자 인덱스나 값으로 역조회가 안됨.
    ```

- 장점 : 일반 문자열보다 타입 안정성이 우수
- 단점 : 존재하지 않는 속성에 접근하더라도 에러가 발생하지 않고 undefined 반환
  - **tsconfig에 어떤 옵션을 설정하더라도 이를 보완할 수 없음**

### const enum

- enum과 형태는 동일
- enum과 차이점은 컴파일 단계에서 const enum은 사라짐

  - 컴파일 단계에서 const enum을 사용한 곳들은 모두 인라인 값으로 대체됨.
  - enum과 달리 컴파일 된 이후 객체가 남지 않기 때문에 bracket notation 사용불가.
  - 사용할 수 있는 방법은 constEnum.key (dot notation) 으로만 접근 가능

- **Number Enum**

  - 타입으로써 value가 특정 숫자였더라도 type: number로 인식 되었음.
  - **하지만, 5.0 부터는 value가 특정 숫자이면 type도 특정 숫자로 제한 (책 오류인듯..)**

  ```tsx
  const enum NumberEnum {
    ONE = 1,
    TWO = 2,
  }

  const a: NumberEnum = 99; // ❌ Error : Type '99' is not assignable to type 'NumberEnum'.ts(2322)
  // NumberEnum = 1 | 2 처럼 동작하기 때문
  ```

- **String Enum**
  - 타입으로써 value가 문자열이면 리터럴로 인식
  ```tsx
  const enum StringEnum {
    ONE = 'ONE',
    TWO = 'TWO',
  }

  const a: StringEnum = 'ONE'; // ❌ Error : Type '"ONE"' is not assignable to type 'STRING_NUMBER'.ts(2322)
  // ONE이지만 StringEnum의 ONE이 아닌 일반 문자열로 인식
  // StringEnum = StringEnum.ONE | StringEnum.TWO
  const myStringNumber: StringEnum = StringEnum.ONE; // O
  const myStringNumber: StringEnum = StringEnum['TWO']; // O

  const b: StringEnum = 'THREE'; // ❌ Error
  ```

## 3.2 ] 타입 조합

---

### 교차 타입 (Intersection)

: & 를 사용하여 여러가지 타입을 단일 타입으로 결합

→ 주의사항 : 같은 타입인 경우 interface과 달리 같은 속성의 타입이 겹칠 경우 교집합으로 적용됨. 접점이 없는 경우 never로 타입이 찍힘.

```tsx
tpye A = { name: string }
type B = { name: number }

type C = A & B
const c: C = { name: 'hi' } // name type "never"
```

### 유니온 타입 (Union)

: | 를 사용하여 여러가지 타입 중 하나 일때 사용.

```tsx
tpye A = { name: string }
type B = { name: number }

type C = A | B
const c: C = { name: 'hi' } // name type : string 아니면 number
```

### 인덱스 시그니처 (Index Signature)

특정 타입의 속성 이름은 알 수 없지만 전체적인 속성값의 타입을 알고 있을 때 사용.

```tsx
interface IndexSignatureEx2 {
  [key: string]: number | boolean;
  length: number;
  isValid: boolean;
  name: string; //에러 발생
}
```

### 인덱스트 엑세스 타입 (Indexed Access Types)

특정 속성에 접근 타입

```tsx
type Example = {
  a: number;
  b: string;
  c: boolean;
};

type IndexedAccess2 = Example['a' | 'b']; // number | string
```

### 맵드 타입 (Mapped Types)

### 템플릿 리터럴 타입 (Template Literal Types)

리터럴을 붙여서 확장할 수 있음

```tsx
type Month = 'jan' | 'feb'. ... 'dec'
type MonthPrefix `${Month}_2025`
```

### 제네릭 (Generic)

확장성있는 타입을 작성하고 싶을 때 주로 활용

```tsx
function exampleFunc<T>(arg: T):T[] }
	return new Array(3).fill(arg);
}
```

## 3.3 ] 제네릭 사용법

---

### 함수의 제네릭

: 함수의 매개변수, 반환값에 다양한 타입을 넣고 싶을 때 제네릭 사용.

- function declaration : 함수 이름뒤에 제네릭을 사용
  ```tsx
  function ReadOnlyRepository**<T>**(
  	target: ObjectType<T> | EntitySchema<T> | string
  ): Repository<T> {
  	return getConnection('ro').getRepository(target);
  }
  ```
- arrow function (호출시그니처) :

### 제네릭 확장과 제한

- 확장 : | union을 활용해서 타입으로 여러개로 확장할 수 있음
- 제한 : extends를 활용해서 특정 타입의 제네릭일 수 있도록 제한

### 주의사항

> 제네릭을 사용하면 확장성이 높고, 가독성을 높이고, 코드를 효율적으로 재사용할 수 있음
> → But, 굳이 필요하지 않은 곳에 사용하면 불필요한 복잡성을 높임

- 제네릭을 굳이 사용하지 않아도 되는 타입
- any 사용하기 : 제네릭을 사용하는 이유는 코드의 재사용성을 높이고, 타입을 추론하는데 사용. But `any` 사용하면 타입 추론 및 타입 검사의 이점을 누릴 수 없기 때문에 가능한 사용을 지양할 것.
  - ex) any가 T 타입의 기본값으로 설정되어 있기 때문에 T를 넘겨주지 않을 경우 타입 추론을 하지 않고 any가 들어가서 정적 타이핑(타입스크립트)의 효과를 얻지 못함.
  ```tsx
  type ReturnType<T = any> = {};
  ```
- 가독성을 고려하지 않은 사용은 최대한 지양 : 가능한 의미가 직관적으로 이해될 수 있는 타입으로 세분화해서 분리.
  - ex) 제네릭 타입들은 OrderType, CommonOrderStatus, CommonReturnStatus, OrderRoleType 이다. 나머지 ReturnType, Record, Partial 은 이미 타이브스크립트에서 제공되는 타입들이다.
  ```tsx
  ReturnType<
    Record<
      **OrderType**,
      Partial<
        Record<
          **CommonOrderStatus** | **CommonReturnStatus**,
          Partial<Record<**OrderRoleType**, string[]>>
        >
      >
    >
  >;
  ```
  ```tsx
  type CommonStatus = CommonOrderStatus | CommonReturnStatus;
  type PartialOrderRole = Partial<Record<OrderRoleType, string[]>>;
  type RecordCommonOrder = Record<CommonStatus, PartialOrderRole>;
  type RecordOrder = Record<OrderType, Partial<RecordCommonOrder>>;

  ReturnType<RecordOrder>;
  ```
