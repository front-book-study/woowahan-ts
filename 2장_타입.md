# `2.1` 타입이란

## 1. 자료형으로서의 타입

- 컴퓨터의 메모리 공간은 한정적
    
    → 특정 메모리에 값을 효율적으로 저장하려면 해당 메모리 공간 차지할 값의 크기를 알아야 함
    
- 자바스크립트의 7가지 데이터 타입(자료형)
    - undefined
    - null
    - Boolean(불리언)
    - String(문자열)
    - Symbol(심볼)
    - Numberic(Number, BigInt)
    - Obejct
<br>

## 2. 집합으로서의 타입

- 프로그래밍에서 타입은 수학의 집합과 유사

```tsx
function double(n: number){
	return n * 2;
}

double(2); // 4
double("z"); // Error🚨 
```

- 일단 타입을 제한하면 TS 컴파일러는 함수를 호출할 때 호환되는 인자로 호출했는지 판단
<br>

## 3. 정적 타입과 동적 타입

- 타입을 결정하는 시점에 따라 `정적 타입(static)` / `동적 타입(dynamic)` 으로 분류

### 정적 타입 시스템 (static)

- 변수 타입이 **컴파일 타임**에 결정됨
- 코드 작성 시 개발자가 타입 명시
- C, Java, TypeScript 등
- 번거로울 수 있지만 컴파일 타임에 타입 에러 발견 가능 → 프로그램 안정성 ⬆️

### 동적 타입 시스템 (dynamic)

- 변수 타입이 런타임에 결정됨.
- Python, JavaScript 등
- 코드를 에러없이 마음껏 작성할 수 있지만 언제 프로그램에 오류가 생길지 모르는 불안감
<br>

## 4. 강타입과 약타입

### 암묵적 타입 변환(Implicit conversion)

개발자가 의도적으로 타입 명시하거나 바꾸지 않았는데도 컴파일로 or 엔진 등에 의해 런타임에 자동으로 타입 변경되는 것

- 암묵적 타입 변환 여부에 따라 `강타입(strongly type)` / `약타입(weakly type)`으로 분류
- **강타입** 언어에서는 서로 다른 타입을 갖는 값끼리 연산 시도 시 컴파일러 or 인터프리터에서 에러 발생🚨
- **약타입** 언어에서는 서로 다른 타입을 갖는 값끼리 연산 시도 시 컴파일러 or 인터프리터에가 내부적으로 판단 후 특정 값의 타입을 변환하여 연산 수행 후 값 도출
<br>

### 빼기(-) 연산자 동작 예시

- C++, Java, JavaScript에서는 서로 다른 타입을 갖는 값으로 빼기(-) 연산 정상적으로 동작
- C++, Java에서는 내부적으로 문자열 타입 값을 숫자 타입(아스키 값)으로 변경해서 연산
- JavaScript에서는 문자열로 표기된 숫자를 실제 숫자 값으로 변환해서 연산
- 이에 반해 Python, Ruby, TypeScript에서는 컴파일러 or 인터프리터에서 타입 에러 발생

결론적으로,

**`약타입`** : C++, Java, JavaScript

**`강타입`** : Python, Ruby, TypeScript

<br>

암묵적 변환은
- 개발자가 명시적으로 타입을 변환하지 않아도 다른 데이터 타입끼리 연산 가능하다는 편리함을 제공
- 하지만, **작성자의 의도와 다르게 동작할 수 있기 때문**에 예상치 못한 오류 발생할 가능성

### 결론

- JS는 약타입 언어이니, 타입을 사용해서 프로그램이 유효하지 않은 작업을 수행하지 않도록 방지
- TS는 명시적 타입 지정과 타입 추론을 모두 지원하여 **더 안전한 코드 작성**을 가능하게 함
<br>

## 5. 컴파일 방식

### 컴파일(Compile)

- 사람이 이해 가능한 방식으로 작성한 코드 → 컴퓨터가 이해할 수 있는 기계어로 바꿔주는 과정
- 서로 다른 수준(고수준-서수준) 간의 코드 변환을 의미

### 타입스크립트의 컴파일

- TS의 컴파일 결과물은 여전히 사람이 이해할 수 있는 방식인 JS 파일
- TS의 탄생 이유는 사람이 이해할 수 있는 코드 작성을 위험이 아니라, 
JS의 컴파일 타임에 런타임 에러를 잡아내기 위함
- Java는 그 자체로 언어지만, 
TS = JS + 타입이라는 레이어를 얹은 일종의 템플릿 언어 or 확장 언어로 해석하는 의견도 있음
<br>

---

# `2.2` 타입스크립트의 타입 시스템

## 1. 타입 애너테이션 방식

### 타입 애너테이션(type annotation)

변수, 상수 or 함수의 인자와 반환 값에 타입을 명시적으로 선언해 어떤 타입 값이 저장될 것인지 컴파일러에게 알려주는 문법

- Java에서는 변수에 데이터 타입 명시하지 않으면 에러 발생
- TS에서는 변수 이름 뒤에 `: type` 구문을 붙여 데이터 타입 명시

```tsx
let isDone: boolean = false;
let decimal: number = 6;
let color: string = "blue";
let list: number[] = [1, 2, 3];
let x: [string, number]; // tuple
```
<br>

## 2. 구조적 타이핑

프로그래밍 언어에서 값 or 객체는 하나의 구체적인 타입을 갖고 있음

### 명목적으로 구체화한 타입 시스템(Nominal Reified Type Systems)

- 타입은 이름으로 구분되며 컴파일 타임 이후에도 남아있음
- 서로 다른 클래스끼리 명확한 상속 관계 or 공통으로 가진 인터페이스가 없다면 타입 서로 호환 X

그러나, TypeScript에서 타입을 구분하는 방식은 조금 다름

이름으로 타입 구분하는 명목적 타입 언어 특징과 달리, **TS는 구조로 타입을 구분** 

= **구조적 타이핑(Structural type system)**

<br>

## 3. 구조적 서브 타이핑

- TypeScript의 타입은 값의 집합(set of values)으로 생각할 수 있음
    
    ```tsx
    type stringOrNumber = string | number;
    ```
    

### 구조적 서브 타이핑

- 객체가 갖고 있는 속성(프로퍼티)을 바탕으로 타입을 구분하는 것
- 이름이 다른 객체라도 가진 속성이 동일하다면 TypeScript는 서로 호환이 가능한 동일 타입으로 여김
- 예제 1
    
    ```tsx
    interface Pet {
    	name: string;
    }
    
    interface Cat {
    	name: string;
    	age: number;
    }
    
    let pet: Pet;
    let cat: Cat = { name: "Zag", age: 2 };
    
    pet = cat; // 가능✅
    cat = pet; // 에러 발생🚨, pet에 age 속성이 없어 할당 불가능
    ```
    
    Cat, Pet은 각각 다른 타입으로 선언됐지만 공통적으로 name이라는 속성 갖고 있음. 
    따라서, Cat 타입의 cat을 Pet 타입의 pet에 할당할 수 있음
    
- 예제 2
    
    ```tsx
    interface Pet {
    	name: string;
    }
    
    let cat = { name: "Zag", age: 2 };
    function greet(pet: Pet) {
        console.log("Hello, " + pet.name);
    }
    
    greet(cat);
    ```
    
    greet 함수 매개변수에는 Pet 타입으로 제한돼 있지만, cat 객체는 Pet 인터페이스가 갖고 있는 name 속성을 갖고 있어 pet.name의 방식으로 name 속성에 접근 가능
    
- 예제 3
    
    ```tsx
    class Person {
        name: string;
        age: number;
    
        constructor(name:string, age:number){
            this.name = name;
            this.age = age;
        }
    }
    
    class Developer {
        name: string;
        age: number;
        sleepTime: number;
    
        constructor(name: string, age: number, sleepTime: number){
            this.name = name;
            this.age = age;
            this.sleepTime = sleepTime;
        }
    }
    
    function greet(p: Person){
        console.log(`Hi, I'm ${p.name}`);
    }
    
    const developer = new Developer("Bin", 20, 7);
    
    greet(developer); // "Hi, I'm Bin"
    ```
    
    Developer 클래스가 Person 클래스를 상속받지 않았지만 greet(developer)는 정상적으로 동작.
    Developer는 Person이 갖고 있는 속성을 가지고 있기 때문.
    
<br>

## 4. 자바스크립트를 닮은 타입스크립트

타입스크립트의 타입 시스템, 즉 **구조적 서브타이핑**은 명목적 타이핑(nominal typing)과는 대조적인 방식.

명목적 타이핑은 타입 구조가 아닌 타입의 이름만으로 구별하는 것으로 C++, Java 등에서 사용.

타입스크립트가 구조적 타이핑을 채택한 이유는, TypeScript가 JavaScript를 모델링한 언어이기 때문.

(JavaScript는 본질적으로 **덕 타이핑(duck typing)** 기반)

> **덕 타이핑**이란?
- 어떤 함수의 매개변수 값이 올바르게 주어진다면 그 값이 어떻게 만들어졌는지 신경 쓰지 않고 사용한다는 개념
- 어떤 타입에 부합하는 변수와 메서드를 가질 경우 해당 타입에 속하는 것으로 간주하는 방식
“만약 어떤 새가 오리처럼 걷고, 헤엄치며 꽥꽥거리는 소리를 낸다면 나는 그 새를 오리라고 부를 것”
> 
<br>

### 덕 타이핑(JS)과 구조적 타이핑(TS)의 차이

객체 변수, 메서드 같은 필드를 기반으로 타입 검사한다는 점은 동일하나, 타입을 검사하는 시점 다름.

- 덕 타이핑(JavaScript) - 런타임에 타입 검사, 주로 동적 타이핑
- 구조적 타이핑(TypeScript) - 컴파일 타임에 타입체커가 타입 검사, 주로 정적 타이핑
<br>

## 5. 구조적 타이핑의 결과

TypeScript 구조적 타이핑의 특징으로 인해 예상치 못한 결과가 나올 때도 있음

- 예제 1
    
    ```tsx
    interface Cube {
        width: number;
        height: number;
        depth: number;
    }
    
    function addLines(c: Cube){
        let total = 0;
    
        for(const axis of Object.keys(c)){
            const length = c[axis];
            // Element implicitly has an 'any' type 
            // because expression of type 'string' can't be used to index type 'Cube'. 
            // No index signature with a parameter of type 'string'
            // was found on type 'Cube'.
    
            total += length;
        }
    }
    ```
    
    Cube 인터페이스의 모든 필드가 number 타입이기 때문에 c[axis]도 당연히 number 타입일 것이라고 예측할 수 있음. 그러나, c에 들어올 객체는 어떤 속성이든 가질 수 있어서 에러 발생🚨
    
    ```tsx
    const namedCube = {
        width: 6,
        height: 5,
        depth: 4,
        name: "SweetCube",
    }
    
    addLines(namedCube); // 가능✅
    ```
    

이처럼 한계를 극복하고자 TypeScript에 명목적 타이핑 언어의 특징을 가미한 **식별할 수 있는 유니온(Discriminated Unions)** 같은 방법이 생겨남
<br>

## 6. 타입스크립트의 점진적 타입 확인

**점진적 타입 검사**란, 컴파일 타임에 타입을 검사하면서 필요에 따라 타입 선언 생략을 허용하는 방식

```tsx
function add(x, y){
	return x + y;
}

// 위 코드는 아래와 같이 암시적 타입 변환이 일어남
function add(x: any, y: any): any;
```

매개변수 x, y에 타입을 명시하지 않아 컴파일러가 x, y와 함수 반환 값을 모두 any 타입으로 추론함.

타입스크립트에서 프로그램을 컴파일하는 데 반드시 모든 타입을 알아야 하는 것은 아님.

그러나 모든 타입을 알고 있을 때 최상의 결과를 보여주는 것은 맞음.

```tsx
const names = ["han", "bin"];
console.log(names[2].toUpperCase());
// 길이가 2인 배열의 인덱스 2에 접근하는데 컴파일 타임에서는 에러 X
// names를 string[]로 추론했지, string | undefined라고 추론하지 않음

// 런타임에서야 에러가 발생함 
// 🚨 Cannot read properties of undefined (reading 'toUpperCase') 
```

타입스크립트는 컴파일 시점에 모든 오류를 완벽히 잡아내지는 못한다.
<br>

## 7. 자바스크립트 슈퍼셋으로서의 타입스크립트

- 모든 자바스크립트 코드는 타입스크립트로 볼 수 있다
- 그러나, 모든 타입스크립트 코드가 자바스크립트 코드인 것은 아니다.
<br>

## 8. 값 vs 타입

### type, interface 키워드로 커스텀 타입 정의

값 공간과 타입 공간의 이름은 서로 충돌하지 않아서 타입과 변수를 같은 이름으로 정의할 수 있는데, 
이는 TS가 JS의 슈퍼셋인 것과 관련 있음.

- type으로 선언한 내용은, JS 런타임에서 제거되기 때문에 값 공간과 타입 공간은 서로 충돌 X

```tsx
type Developer = { isWorking: true };
const Developer = { isTyping: true }; // ✅

type Cat = { name: string; age: number };
const Cat = { slideStuffOffTheTable: true } // ✅
```
<br>

### 클래스

클래스는 객체 인스턴스를 더욱 쉽게 생성하기 위한 문법 기능으로 실제 동작은 함수와 같은데, 동시에 타입으로도 사용됨.

- 예제
    
    ```solidity
    class Rectangle {
      constructor(height, width) {
        this.height = height;
        this.width = width;
      }
    }
    
    const rect1 = new Rectangle(5, 4);
    ```
    
    ```tsx
    class Developer {
      name: string;
    
      domain: string;
    
      constructor(name: string, domain: string) {
        this.name = name;
        this.domain = domain;
      }
    }
    
    const me: Developer = new Developer("zig", "frontend");
    ```
    
    변수명 `me` 뒤에 등장하는 `: Developer`에서 `Developer`는 타입에 해당하지만, `new` 키워드 뒤의 `Developer`는 클래스의 생성자 함수인 값으로 동작
    
<br>

### enum

- **enum** 역시 런타임에 객체로 변환되는 값. 런타임에 실제 객체로 존재하며, 함수로 표현할 수도 있음.
- 예제 1
    
    ```tsx
    enum Direction {
      Up, // 0
      Down, // 1
      Left, // 2
      Right, // 3
    }
    ```
    
    ```tsx
    // 순수 자바스크립트 코드로 컴파일한 결과
    let Direction;
    (function (Direction) {
      Direction[(Direction.Up = 0)] = "Up";
      Direction[(Direction.Down = 1)] = "Down";
      Direction[(Direction.Left = 2)] = "Left";
      Direction[(Direction.Right = 3)] = "Right";
    })(Direction || (Direction = {}));
    ```
    
- 클래스처럼 타입 공간에서 타입을 제한하는 역할을 하지만 JS 런타임에서 실제 값으로도 사용될 수 있음
- 예제 2
    
    ```tsx
    // enum이 타입으로 사용된 경우
    enum WeekDays {
      MON = "Mon",
      TUES = "Tues",
      WEDNES = "Wednes",
      THURS = "Thurs",
      FRI = "Fri",
    }
    // ‘MON’ | ‘TUES’ | ‘WEDNES’ | ‘THURS’ | ‘FRI’
    type WeekDaysKey = keyof typeof WeekDays;
    
    function printDay(key: WeekDaysKey, message: string) {
      const day = WeekDays[key];
      if (day <= WeekDays.WEDNES) {
        console.log(`It’s still ${day}day, ${message}`);
      }
    }
    
    printDay("TUES", "wanna go home");
    ```
    
    ```tsx
    // enum이 값 공간에서 사용된 경우
    enum MyColors {
      BLUE = "#0000FF",
      YELLOW = "#FFFF00",
      MINT = "#2AC1BC",
    }
    
    function whatMintColor(palette: { MINT: string }) {
      return palette.MINT;
    }
    
    whatMintColor(MyColors); // ✅
    ```
    
<br>

## 9. 타입을 확인하는 방법

### (1) typeof

- 반환값: `Boolean`, `null`, `undefined`, `Number`, `BigInt`, `String`, `Symbol`, `Function`, `object` 등
- TypeScript의 typeof 연산자는 `값`에서 쓰일 때 / `타입`에서 쓰일 때 역할이 다름
    - `값`에서 사용됐을 때
        
        ```tsx
        interface Person {
            first: string;
            last: string;
        }
        
        const person: Person = { first:"hanbin", last: "lee" };
        
        function email(options:{
            person: Person;
            subject: string;
            body: string
        }) {}
        
        const v1 = typeof person;
        const v2 = typeof email;
        
        console.log(v1, v2); // "object", "function"
        ```
        
        - `값`에서 사용될 때 : 자바스크립트 런타임의 typeof 연산자가 됨
    - `타입`에서 사용됐을 때
        
        ```tsx
        interface Person {
            first: string;
            last: string;
        }
        
        const person: Person = { first:"hanbin", last: "lee" };
        
        function email(options:{
            person: Person;
            subject: string;
            body: string
        }) {}
        
        type T1 = typeof person; // T1의 타입 = Person
        type T2 = typeof email; // T2의 타입 = (options: { person: Person; subject: string; body: string; }) => void
        ```
        
        - `타입`에서 사용될 때 : 값을 읽고 타입스크립트 타입을 반환
- 자바스크립트 클래스에서 typeof 연산자 사용 시 주의할 점❗

```tsx
class Developer {
    name: string;
    sleepingTime: number;

    constructor(name: string, sleepingTime: number) {
        this.name = name;
        this.sleepingTime = sleepingTime;
    }
}

const d = typeof Developer; // 값 공간, d = "function"
type T = typeof Developer; // 타입 공간, T = typeof Developer
```

자바스크립트에서 클래스는 결국 함수이기 때문에 값 공간에서 typeof Developer의 값 = function.

타입 공간에서 typeof Developer의 반환 값, 즉 T의 값은 조금 특이한데 T에 할당된 Developer는 인스턴스 타입이 아니라, new 키워드를 사용할 때 볼 수 있는 **생성자 함수**이기 때문

### (2) instanceof

- JavaScript에서 instanceof 연산자를 사용하면 프로토타입 체이닝 어딘가에 생성자의 프로토타입 속성이 존재하는지 판단 가능

```tsx
let error = unknown;

// error가 정말 Error의 인스턴스인지 확인 
if (error instanceof Error){
    showAlertModal(error.message);
} else {
    throw Error(error);
}
```

### (3) 타입 단언

- as 키워드 사용하여 타입을 강제
- 개발자가 해당 값의 타입을 더 잘 파악할 수 있을 때 사용되며 강제 형 변환과 유사한 기능 제공

```tsx
// 어딘가에서 unknown 타입 값을 전달받았다고 가정
const loaded_text: unknown;

const validateInputText = (text: string) => {
    if (text.length < 10) return "최소 10글자 이상 입력";
    return "정상 입력됨";
};

validateInputText(loaded_text as string);
// as 키워드를 사용해 string으로 강제하지 않으면 TS 컴파일러 단계에서 에러 발생
```

---

# `2.3` 원시 타입

> **원시 값과 원시 래퍼 객체** 
자바스크립트에서는 원시 값에 대응하는 원시 래퍼 객체가 있지만, 타입스크립트에서는 원시 값과 원시 래퍼 객체를 구분하여 사용. 타입스크립트에서는 원시 값에 대응하는 타입을 소문자로 표기하며, 파스칼 표기법을 사용하면 해당 원시 값을 래핑하는 객체 타입을 의미. 따라서, 타입스크립트에서는 원시 값과 원시 래퍼 객체를 구분하여 사용해야 함.
> 

## 1. boolean

## 2. undefined

오직 `undefined` 값만 할당할 수 있으며, 초기화되어 있지 않거나 존재하지 않음을 의미

```tsx
let value: string;
console.log(value); // undefined (값이 아직 할당되지 않음)

type Person = {
  name: string;
  job?: string;
};
```

`Person`타입의 `job` 속성은 옵셔널로 지정돼 있는데 이런 경우에도 `undefined`를 할당 가능

## 3. null

오직 `null`만 할당할 수 있음

```tsx
let value: null | undefined;
console.log(value); // undefined (값이 아직 할당되지 않음)

value = null;
console.log(value); // null
```

```tsx
type Person1 = {
  name: string;
  job?: string; // job이라는 속성이 있을 수도 또는 없을 수도 있음
};

type Person2 = {
  name: string;
  job: string | null; // 속성을 가지고 있지만 값이 비어있을 수 있음 (무직 상태)
};
```

## 4. number

- Java와 달리, 어떤 숫자든 모두 number 타입에 할당 가능
- NaN, Infinity 등

## 5. bigInt

- ES2020에서 새롭게 도입된 데이터 타입 (TypeScript 3.2버전부터 사용 가능)
- number와 bigInt 타입은 엄연히 다른 타입이라 상호 작용은 불가능

## 6. string

## 7. symbol

- `Symbol()` 함수를 사용하면 어떤 값과도 중복되지 않는 유일한 값을 생성할 수 있음

```tsx
const MOVIE_TITLE = Symbol("title");
const MUSIC_TITLE = Symbol("title");
console.log(MOVIE_TITLE === MUSIC_TITLE); // false

let SYMBOL: unique symbol = Symbol(); // A variable whose type is a 'unique symbol'
// type must be 'const'
```

---

# `2.4` 객체 타입

## 1. object

가급적 사용하지 않도록 권장되는데, 객체에 해당하는 모든 타입 값을 유동적으로 할당할 수 있어 정적 타이핑의 의미가 크게 퇴색되기 때문.

```tsx
// 매개변수 value가 객체인지 확인하는 함수
function isObject(value: object) {
  return (
    Object.prototype.toString.call(value).replace(/\[|\]|\s|object/g, "") ===
    "Object"
  );
}

// 객체, 배열, 정규 표현식, 함수, 클래스 등 모두 object 타입과 호환됨
isObject({});
isObject({ name: "KG" });
isObject([0, 1, 2]);
isObject(new RegExp("object"));
isObject(() => {
  console.log("hello wolrd");
});
isObject(class Class {});
```

## 2. {}

타입스크립트에서는 객체의 각 속성에 대한 타입을 중괄호 `{}` 안에 지정할 수 있음.

- 예제
    
    ```tsx
    // 정상✅
    const noticePopup: { title: string; description: string } = {
      title: "IE 지원 종료 안내",
      description: "2022.07.15일부로 배민상회 IE 브라우저 지원을 종료합니다.",
    };
    
    // Error
    const noticePopup: { title: string; description: string } = {
      title: "IE 지원 종료 안내",
      description: "2022.07.15일부로 배민상회 IE 브라우저 지원을 종료합니다.",
      startAt: "2022.07.15 10:00:00", // 🚨startAt은 지정한 타입에 존재하지 않으므로 오류
    };
    ```
    

빈 객체를 생성할 때도 `{}`를 사용할 수 있지만, `{}` 타입으로 지정된 객체에는 어떤 값도 속성으로 할당할 수 없음.

- 예제
    
    ```tsx
    let noticePopup: {} = {};
    
    noticePopup.title = "IE 지원 종료 안내"; // (X) title 속성을 지정할 수 없음
    ```
    
    `{}` 타입으로 지정된 객체는 완전히 비어있는 순수한 객체를 의미하는 것 X
    
    그러나 자바스크립트의 프로토타입 체이닝 때문에 아래와 같이 기본 Object 객체의 메서드는 사용 가능
    
    ```tsx
    console.log(noticePopup.toString()); // [object Object]
    ```
    
    이와 같은 이유로 타입스크립트에서 객체 래퍼를 타입으로 지정할 수 있는데도 소문자로 된 타입스크립트 타입 체계를 사용하는 게 일반적
    

## 3. array

JavaScript의 배열 자료구조는 원소를 자유롭게 추가 및 제거 가능하며 타입 제한 없이 다양한 값을 다룸

그러나 이는 **TypeScript가 추구하는 정적 타이핑 방향과는 맞지 않음**

TypeScript 배열 타입은 **하나의 타입 값만 가질 수 있다**는 점에서 JavaScript 배열보다 더 엄격함

Array 키워드로 선언하거나 대괄호(`[]`)를 사용해서 선언, 개인 취향 or 팀 컨벤션에 맞춰 사용

- 예제
    
    ```tsx
    const getCartList = async (cartId: number[]) => {
      const res = await CartApi.GET_CART_LIST(cartId);
      return res.getData();
    };
    
    getCartList([]); // (O) 빈 배열도 가능하다
    getCartList([1001]); // (O)
    getCartList([1001, 1002, 1003]); // (O) number 타입 원소 몇 개가 들어와도 상관없다
    getCartList([1001, "1002"]); // (X) ‘1002’는 string 타입이므로 불가하다
    ```
    

주의해야 할 점: **튜플 타입**도 대괄호로 선언한다는 것

배열과 유사하지만 튜플의 대괄호 내부에는 선언 시점에 지정해준 타입 값만 할당할 수 있음

원소 개수도 타입 선언 시점에 미리 정해짐.

- 예제
    
    ```tsx
    const targetCodes: ["CATEGORY", "EXHIBITION"] = ["CATEGORY", "EXHIBITION"]; // (O)
    const targetCodes: ["CATEGORY", "EXHIBITION"] = [
      "CATEGORY",
      "EXHIBITION",
      "SALE",
    ]; // (X) SALE은 지정할 수 없음
    ```
    

## 4. type과 interface 키워드

실무에서는 타입스크립트 object 타입은 잘 사용하지 않음.

객체를 타이핑하기 위해 자주 사용하는 키워드로 `type`과 `interface`가 있음

```tsx
type NoticePopupType = {
    title: string;
    description: string;
}

interface INoticePopup {
    title: string;
    description: string;
}

const noticePopup1: NoticePopupType = { ... };
const noticePopup2: INoticePopup = { ... };
```

## 5. function

함수는 **매개변수** 그리고 **반환 값**에 대해서도 타입 지정을 해야 함.

```tsx
function add(a: number, b: number): number {
	return a + b;
}
```

함수 자체의 타입 지정은 **호출 시그니처**를 사용

> **호출 시그니처(Call Signature)** 
타입스크립트에서 함수 타입을 정의할 때 사용하는 문법. 함수 타입은 해당 함수가 받는 매개변수와 반환하는 값의 타입으로 결정됨. 호출 시그니처는 이러한 함수의 매개변수와 반환 값의 타입을 명시하는 역할

- 예제
    ```tsx
    type add = (a: number, b: number) => number;
    ```
    
타입스크립트에서 함수의 타입을 명시할 때는 화살표 함수 방식으로 호출 시그니처를 정의.
이 방식은 자바스크립트의 화살표 함수와 유사하며 함수의 입력 파라미터, 반환 값의 타입을 명시할 수 있음
