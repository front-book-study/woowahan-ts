### 3.1 타입스크립트만의 독자적 타입 시스템
타입스크립트의 타입 시스템이 내포하고 있는 개념은 모두 자바스크립트에서 기인한 것이다. 
하지만 타입스크립트의 `any` 타입은 자바스크립트를 추적해봐도 찾아볼 수 없는데 ( === 타입스크립트에만 존재하는 독자적인 타입 시스템) any 타입의 개념은 이미 자바스크립트에서 널리 사용되고 있다.  어떤 타입이든 매핑할 수 있는 성질이 원래 자바스크립트의 사용 방식과 일치하기 때문이다. 

#### any
any 타입은 자바스크립트에 존재하는 모든 값을 오류 없이 받을 수 있다. 즉 타입을 명시하지 않으 것과 동일한 효과를 나타낸다. 
이는 정적타이핑을 위해 타입스크립트의 목적을 무시하고 자바스크립트의 동적 타이핑으로 돌아가는 것과 비슷한 결과를 가져오기 때문에 지양해야할 패턴으로 간주된다. 
하지만 어쩔 수 없이 any를 사용해야 하는 경우가 있는데 대표적으로 3가지 사례를 들 수 있다.
1) 개발 단계에서 임시로 값을 지정해야할 때
추후 값이 변경될 가능성이 있거나 아직 세부항목에 대한 타입이 확정되지 않을 경우 해당 값을 any로 지정하고 진행할 수 있다. 
(하지만 추후 세부 스펙이 나오면 any를 제거해줘야 함)

2) 어떤 값을 받아올지 또는 넘겨줄지 정할 수 없을 때
API 요청 및 응답 처리, 콜백 함수 절달, 타입이 잘 정제되지 않아 파악이 힘든 외부 라이브러리등을 사용할 때는 any를 사용할수 있다.

3) 값을 예측할 수 없을 때 암묵적으로 사용
외부 라이브러리나 웹 API의 요청에 따라 다양한 값을 반환하는 API가 존재할 수 있는데 이 경우 반환 타입을 알지 못할때 any를 매핑하기도 한다. 

#### unknown 
unkwown 타입은 any와 유사하게 모든 타입의 값이 할당될 수 있다. 그러나 any를 제외한 다른 타입으로 선언된 변수에는 unknown 타입 값을 할당할 수 없다. 
unknown타입은 타입스크립트 3.0이 릴리즈 될 때 추가되었는데 기존 타입 시스템에서 부족한 부분을 보완하기 위해 등장했다. 

- 어떤 값이든 할당 가능
- 하지만 unknown 타입 값을 바로 사용하려 하면 에러 발생(컴파일 단계에서)
- 사용하려면 먼저 타입 좁히기나 타입 단언이 필요


#### void 
자바스크립트에서는 함수에서 명시적인 반환문을 작성하지 않으면 기본적으로 undefined가 반환된다. 하지만 타입스크립트에서는 어떤 값을 반환하지 않는 경우에는 void를 지정해서 사용한다. 

#### never
값을 반환할 수 없는 타입이다. 여기서 값을 반환하는 것과 반환할 수 없는 것을 명확히 구분해야 한다.

- 에러를 던지는 경우
`throw` 키워드를 사용하면 에러를 발생시킬 수 있는데, 이는 값을 반환하는 것으로 간주하지 않는다. 
-> 특정 함수가 실행 중 마지막에 에러를 던지는 작업을 수행한다면 해당 함수의 반환 타입은 `never`이다.

- 무한히 함수가 실행되는 경우
무한 루프는 결국 함수가 종료되지 않음을 의미하기 때문에 값을 반환하지 못한다.

never타입은 모든 타입의 하위 타입이다(모든 타입의 서브타입) -> 어떤 타입도 never에 할당할 수 없음
따라서 조건부 타입을 결정할 때 특정 조건을 만족하지 않는 경우에 엄격한 타입 검사 목적으로 never 타입을 명시하기도 한다.

#### Array 
- 자바스크립트에서는 배열을 객체에 속하는 타입으로 분류한다. ->즉 자바스크립트에서는 배열을 단독으로 배열이라는 자료형에 국한하지 않는다. 
- 타입스크립트에서 `Array` 라는 타입을 사용하기 위해서는 타입스크립트의 특수한 문법을 함께 다뤄야 한다.

자바스크립트의 배열은 동적 언어의 특성에 따라 어떤 값이든 배열의 원소로 허용한다 (ex. [1, "String", fn])
이는 하나의 타입만 사용하도록 명시하는 정적 타이핑과는 부합하지 않는다.


튜플을 사용하면 배열의 값과 길이를 고정할 수 있다. 
예를들어 react의 `useState`는 튜플 타입을 반환한다. 
```
const [value, setValue] = useState();
// 첫번째 원소: 상태값
// 두번째 원소: 상태를 조작하는 setter
```
위와 같이 튜플을 사용하면 반환 값이 명확하고 API의 설계 의도를 잘 파악할 수 있다.

```
const httpStatusFromPaths: [number, string, ...string[]] = [
400, 
"Bad Request",
"users/:id",
"users/"userId",
]
```
또한 튜플과 배열의 성질을 혼합해서 사용할 수 있다. 다음과 같이 스프레드 연산자를 사용하여 특정 인덱스에서 요소를 명확한 타입으로 선언하고 나머지 인덱스에서는 배열처럼 동일한 자료형의 원소를 개수 제한 없이 받도록 할 수 있다.
-> 이건 fetcher같은 함수 만들때 쓰면 좋겠네유... 지금까지는 union array만 사용했는데 이런 방법이 훨 좋은 거 같아요. 


#### enum
enum은 일종의 구조체를 만드는 타입 시스템이다. 열거형을 정의할 수 있는데 각각의 멤버를 가지고 있다. 자바스크립트의 객체와 닮았지만 (모양새는) 타입스크립트는 명명한 각 멤버의 값을 스스로 추론한다. 기본적인 추론방식은 숫자 0부터 1씩 늘려가며 값을 할당한다. 
이전장에서 설명한 enum vs const enum


### 3.2 타입 조합
#### 1.교차타입(Intersection)
교차타입을 사용하면 여러가지 타입을 결합하여 하나의 단일 타입으로 만들 수 있다. `&`을 사용해 표기한다.

#### 2. 유니온 타입(Union)
유니온 타입은 A 또는 B 중 하나가 될 수 있는 타입을 말하며 `A | B` 같이 표기한다. 

#### 3. 인덱스 시그니처(Index Signatures)
인덱스 시그니처는 특정 타입의 속성 이름은 알 수 없지만 속성값의 타입을 알고 있을때 사용하는 문법이다. 
`[Key: K]: T` 꼴로 명시한다. 

#### 4. 인덱스드 엑세스 타입(Indexed Access Types)
다른 타입의 특정 속성이 가지는 타입을 조회하기 위해 사용된다. 


#### 5. 맵드 타입(Mapped Types)
다른 타입을 기반으로 한 타입을 선언할 때 사용하는 문법이다. 인덱스 시그니처 문법을 사용해서 반복적인 타입 선언을 효과적으로 줄일 수 있다.
```
type Example = {
    a: number;
    v: string;
    c: boolean;
}

type Subset<T> = {
    [K in keyof T]?: T[K]
}
```

맵드 타입에서 매핑할때는 `readonly`(읽기전용)와 `?`(옵셔널)를 수식어로 적용할 수 있다.
또한 기존 타입에 존재하던 readonly나 ?앞에 -를 붙여주면 해당 수식어를 제거한 타입을 선언할 수 있다. 

배민 사례 넘 좋네요,,, 특히 as로 단언해서 확장 + 재활용하는 부분


#### 6 템플릿 리터럴 타입(Template Literal Types)
자바스크립트의 템플릿 리터럴 문자열을 사용하여 문자열 리터럴 타입을 선언할 수 있는 문법이다. 
```
type State = "init" | "selected-image"
type StageName = `${Stage}-stage`;
```

#### 7. 제네릭(Generic)
함수, 타입, 클래스 등에서 내부적으로 사용할 타입을 미리 정해두지 않고 타입 변수를사용해서 해당 위치를 비워 둔 다음에, 실제로 그 값을 사용할 때 외부에서 타입 변수 자리에 타입을 지정하여 사용하는 방식을 말한다. 
-> 재 사용성이 커진다.

작성중.. 

### 3.3 제네릭 사용법
#### 1. 함수의 제네릭

