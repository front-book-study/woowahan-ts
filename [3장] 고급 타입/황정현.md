## any 타입

- 자바스크립트에 존재하는 모든 값을 오류 없이 받을 수 있음

### any타입을 어쩔 수 없이 사용해야하는 대표적 3가지 사례

**1. 개발 단계에서 임시 값 지정**

**2. 어떤 값을 받아올지 또는 넘겨줄지 정할 수 없을 때**

> e.g. 모달 창을 그릴 때 실행될 함수의 타입

**3. 값을 예측할 수 없을 때**

> e.g. fetch API 의 response.json()은 `Promise<any>` 타입으로 정의됨

## unknown 타입

**any**

- 어떤 타입이든 any 타입에 할당 가능
- any 타입은 어떤 타입으로도 할당 가능 (never 제외)

**unknown**

- 어떤 타입이든 unknown에 할당 가능
- unknown 타입은 any 타입 외에 다른 타입으로 할당 불가능

### unknown 타입 등장 배경

```tsx
// 할당 시점 에러 발생 x
const unknownFunc: unknown = () => console.log(..)

// 실행 시 에러 발생 (Error: Object is of type 'unknown'.ts)
unknownFunc()
```

어떤 타입이 할당되었는지 알 수 없음을 나타내기 때문에 unknown 타입으로 선언된 변수는 값을 가져오거나 내부 속서에 접근할 수 없음

이는 unknown 타입으로 할당된 변수는 어떤 값이든 올 수 있음을 의미하는 동시에 개발자에게 엄격한 타입 검사를 강제하는 의도

임시로 문제를 회피하기 위해 any 타입을 지정한 후 수정해야 하는 것을 깜빡하고 누락하면 어떤 값이든 전달될 수 있기 때문에 런타임에 버그 발생 가능성이 높아짐

unknown은 이런 상황을 보완하기 위해 등장했으며, any와 유사하지만 타입 검사를 강제하고 타입이 식별된 후에 사용할 수 있기 떄문에 any 보다 안전

따라서 데이터 구조를 파악하기 힘들 때 any 대신 unknown 타입으로 대체해서 사용하는 방법 권장

```
우형 이야기

any, unknown 타입을 어떻게 사용할까?

공통적으로 any를 지양

unknown 실제 사용 예시

- unknown 은 타입 캐스팅을 통한 타입 전환 시
- 뭔지 모르지만 하나씩 테스트하면서 알아내보자
- try-catch 에러 타입이 unknown이라, 에러 핸들링 시 사용
```

## void

함수가 아무런 값을 반환하지 않는 경우 사용

일반적으로 함수 자체를 다른 함수의 인자로 전달하는 경우가 아니면 생략

## never 타입

값을 반환할 수 없는 타입

모든 타입의 하위 타입 (즉, never 자신을 제외한 어떤 타입도 never 타입에 할당될 수 없음 any 포함)

### 값을 반환할 수 없는 예시

1. 에러를 던지는 경우
    1. 특정 함수가 실행 중 마지막에 에러를 던지는 작업을 수행할 때
    
    ```tsx
    function generateError(res: Response): never {
    	throw new Error(res.getMsg())
    }
    ```
    
2. 무한히 함수가 실행되는 경우

## Array

## enum 타입

## 교차 타입: &

**A & B** 

- A와 B모두 만족하는 타입

## 유니온 타입: |

**A | B**

- A 또는 B 중 하나가 될 수 있는 타입

```tsx
interface Product {
  id: number;
  name: string;
  type: string;
  price: number;
  imageUrl: string;
  quantity: number;
}

interface Item {
  additionalInfo: string;
}

type mergeItem = Product | Item;

const prin = (item: mergeItem) =>{
    console.log(item.name)  //Property 'name' does not exist on type 'mergeItem'.
//  Property 'name' does not exist on type 'Item'. 
}
```

에러 이유: 타입 안전성을 위해 공통 속성만 직접 접근 가능하게 한다.

### 추천 해결방법: 타입 좁히기

1. in

```tsx
const prin = (item: mergeItem) => {
    if ('name' in item) {
        console.log(item.name); // item이 Product 타입일 때만 접근 가능
    }

    if ('additionalInfo' in item) {
        console.log(item.additionalInfo); // item이 Item 타입일 때만 접근 가능
    }
};
```

2.  **디스크리미네이티드 유니온 + 리터럴 타입 가드의 조합**  

```tsx
interface Product {
  kind: "product"; // 디스크리미네이터 필드
  id: number;
  name: string;
}

interface Item {
  kind: "item"; // 디스크리미네이터 필드
  additionalInfo: string;
}

type mergeItem = Product | Item;

const prin = (item: mergeItem) => {
  if (item.kind === "product") {
    console.log(item.name); // Product 타입으로 좁혀짐
  } else if (item.kind === "item") {
    console.log(item.additionalInfo); // Item 타입으로 좁혀짐
  }
};
```


## 인덱스 시그니처

특정 타입의 속성 이름은 알 수 없지만 속성값의 타입을 알고 있을 때 사용

```tsx
interface IndexSignature {
	[key:string]: number;

	// 특정 타입 추가 선언 시 인덱스 시그니처에 포함된 타입이어야 함
	age: number // o
	name: string // x 
}
```

<aside>
🚨

 인덱스시그니처에서 key 타입은 ***string, number, symbol, Template literal*** 타입과 그들의 유니온만 가능      

</aside>

```tsx
type KeyPrefix = 'user' | 'admin';

// 템플릿 리터럴 사용 예시
type CustomObject = {
    [key in `${KeyPrefix}_id`]: number;
};

const cu: CustomObject = {
    user_id: 12324,
    admin_id: 2121312
}
```

## 인덱스드 엑세스 타입

타입에서 특정 속성의 타입을 추출

```tsx
type Person = { age: number; name: string; alive: boolean };
// Indexed Access Types
type Age = Person["age"];  // number
```

https://github.com/toss/frontend-fundamentals/discussions/45#discussioncomment-11830597

```tsx
// ./types.ts
export type Bookmark = {
    id: number;
    title: string;
    created_at: string;
    // ... 더 많은 필드들
  };

 export type BookmarkResponseType = {
    bookmarks: Bookmark[];
  };

// Indexed Access Types
import type { BookmarkResponseType } from "./types.ts"
type Bookmark = BookmarkResponseType["bookmarks"][number]  // Bookmark

// import specific type at types.ts
import type { Bookmark } from "./types.ts"
```

그런데 우리가 **배열 요소의 타입**이 필요하다면, 다시 한 번 인덱싱을 할 수 있음


## 맵드 타입

기존에 정의되어 있는 타입을 새로운 타입으로 변환해 주는 문법

## 템플릿 리터럴 타입

## 제네릭

내부적으로 사용할 타입을 미리 정해두지 않고 타입 변수를 사용하여 선언

그 값을 사용할 때 외부에서 타입 변수 자리에 타입을 지정해서 사용

### 제네릭 기본값

```tsx
T = HTMLElement
```

### 제네릭 제약

```tsx
interface TypeWithLength {
	length: number;
}

T extends TypeWithLength
```

## 제네릭 사용법

### 함수의 제네릭

### 호출 시그니처의 제네릭

### 제네릭 클래스

### 제한된 제네릭

```tsx
interface Food { name: string; calories: number; }
interface Drink { name: string; volume: number; }

// ❌ 불필요한 제네릭 - 유니온 타입으로 충분
function getName<T extends Food | Drink>(item: T): string {
  return item.name;
}

// ✅ 유니온 타입이 더 적절
function getName(item: Food | Drink): string {
  return item.name;
}

// ✅ 제네릭이 의미 있음
function clone<T extends Food | Drink>(item: T): T {
  return { ...item };
}

const pizza: Food = { name: "Pizza", calories: 300 };
const coffee: Drink = { name: "Coffee", volume: 200 };

const clonedPizza = clone(pizza); // 타입: Food (T가 Food로 추론됨)
const clonedCoffee = clone(coffee); // 타입: Drink (T가 Drink로 추론됨)

// 만약 유니온 타입을 썼다면
function cloneUnion(item: Food | Drink): Food | Drink {
  return { ...item };
}

const clonedPizza2 = cloneUnion(pizza); // 타입: Food | Drink (정확하지 않음)
```

### 확장된 제네릭

### 실무 예시

- **API 응답 값 타입 지정**
