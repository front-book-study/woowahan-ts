# `3.1` 타입스크립트만의 독자적 타입 시스템

## 1. any 타입

: 타입을 명시하지 않은 것과 동일한 효과

- any 타입은 TypeScript로 달성하고자 하는 정적 타이핑을 무색하게 만들 수 있음
- `tsconfig.json` 파일에서 `noImplicitAny` 옵션 활성화 시 any 타입에 대한 경고 발생

<br>

### any 타입을 어쩔 수 없이 사용해야 하는 3가지 상황

#### 1️⃣ 개발 단계에서 임시로 값을 지정해야 할 때

- 복잡한 구성 요소로 이루어진 개발 과정에서 추후 값이 변경될 가능성이 있거나 세부 항목에 대한 타입이 아직 확정되지 않은 경우
- 해당 값을 any로 지정하여 경고 없이 개발 진행
- 그러나, any 타입을 남발하면 **타입 안정성 저해**할 수 있음

<br>

#### 2️⃣ 어떤 값을 받아올지 or 넘겨줄지 정할 수 없을 때

- JavaScript 입장에서는 **어떤 값의 타입을 명확히 지정하기 어려운 상황** 발생할 수 있음<br> ex) API 요청 및 응답 처리, 콜백 함수 전달, 타입이 잘 정제되지 않아 파악이 힘든 외부 라이브러리
<details>
<summary>예제</summary>

```tsx
// 피드백을 나타내기 위해 모달 창을 그릴 때 사용되는 인자를 나타내는 타입
type FeedbackModalParams = {
  show: boolean;
  content: string;
  cancelButtonText?: string;
  confirmButtonText?: string;
  beforeOnClose?: () => void;
  action?: any; // 모달 창을 그릴 때 실행될 함수
};
```

모달 창을 화면에 그릴 때 다양한 액션에 따라 인자의 개수 or 타입을 일일이 명시하기 힘들 수 있음 → `any` 타입을 사용해 다양한 액션 함수 전달 가능

</details>

<br>

#### 3️⃣ 값을 예측할 수 없을 때 암묵적으로 사용

- 외부 라이브러리나 웹 API 요청에 따라 다양한 값을 반환하는 API 존재 가능<br> ex) 브라우저의 Fetch API
- Fetch API 일부 메서드는 요청 이후 응답을 특정 포맷으로 파싱하는데, 이때 반환 타입이 any로 매핑됨

```ts
async function load() {
  const response = await fetch("https://api.com");
  const data = await response.json();
  // respone.json()의 리턴 타입은 Promise<any>로 정의되어 있음
  return data;
}
```

<br>

> 이렇게 예외도 있지만 **되도록 any 타입은 지양하는 게 좋음**

<br> 
<br>

## 2. unknown 타입

- any 타입에만 할당할 수 있음
- 기존 타입 시스템에서 부족한 부분을 보완하기 위해 등장
- **무엇이 할당될지 아직 모르는 상태의 타입**을 말함

```ts
// 할당할 때는 에러 발생 X
const unknownFunction: unknown = () => console.log("this is unknown type");

// 실행 시에는 에러 발생 🚨
unknownFunction();
```

- 함수뿐만 아니라 객체 속성 접근, 클래스 생성자 호출을 통한 인스턴스 생성 등 **객체 내부 접근하는 모든 시도에서 에러 발생**
- unknown 타입은 어떤 타입이 할당됐는지 알 수 없음을 의미<br>= unknown 타입으로 선언된 변수는 값을 가져오거나 내부 속성에 접근 불가능
- unknown 타입은 어떤 값이든 올 수 있음과 동시에 **개발자에게 엄격한 타입 검사를 강제하는 의도**

<br>

### any 타입의 단점을 보완하기 위해 나온 unknown 타입

> **any 타입의 단점**<br>임시로 any 타입을 지정하여 문제를 회피하고, 나중에 any 타입을 수정해야 하는 것을 깜빡하고 누락하면 런타임에 예상치 못한 버그가 발생할 가능성 🚨

- unknown 타입은 이런 상황을 보완하기 위해 등장한 타입
- any 타입과 유사하지만, 타입 검사를 강제하고 타입이 식별된 후 사용 가능하기 때문에 any 타입보다 더 안전

<br>

## 3. void 타입

- 아무런 값을 반환하지 않는 경우에 사용<br> ex) 콘솔에 로그 출력하거나 다른 함수를 실행하는 역할만 함수의 경우
- JavaScript 함수에서 명시적인 반환문 작성하지 않으면 기본적으로 undefined가 반환
- 하지만 TypeScript에서는 void 타입이 사용되고, 이것은 undefined가 아님
- void 타입의 변수는 **undefined 또는 null 값만 할당 가능**<br>( `tsconfig.json`에서 `strictNullChecks` 옵션이 true면 null 값 할당 불가능 )

<br>

## 4. never 타입

: 값을 반환할 수 없는 타입

### JavaScript에서 값을 반환할 수 없는 경우

#### 1️⃣ 에러를 던지는 경우

- JavaScript에서는 런타임에 의도적으로 에러를 발생시키고 캐치할 수 있음
- `throw` 키워드를 통해 에러를 발생시키는데, 이는 값을 반환하는 것으로 간주 X<br>= 특정 함수가 실행 중 마지막에 에러를 던지는 작업을 수행한다면 해당 함수의 반환 타입은 `never`

```ts
function generateError(res: Response): never {
  throw new Error(res.getMessage());
}
```

#### 2️⃣ 무한히 함수가 실행되는 경우

- 무한 루프는 결국 함수가 종료되지 않음을 의미하기 때문에 값을 반환하지 못함

```ts
function checkStatus(): never {
  while (true) {
    //...
  }
}
```

<br>

never 타입은 **모든 타입의 하위 타입**<br>= 자신을 제외한 어떤 타입(any 포함)도 never 타입에 할당 불가능

<br>

## 5. Array 타입

- JavaScript에서는 배열을 객체에 속하는 타입으로 분류<br>즉, JavaScript에서는 배열을 단독으로 배열이라는 자료형에 국한하지 않음
- JavaScript에서는 하나의 배열에 숫자, 문자열, 객체, 함수 등 자료형에 상관없이 원소를 삽입 & 관리할 수 있음
<details>
<summary>숫자형, 문자열 등 여러 타입 관리하는 배열 선언</summary>

```ts
const array1: Array<number | string> = [1, "string"];
const array2: (number | string)[] = [1, "string"];
```

</details>
<br>

### 튜플

: 기존 배열 기능에 **길이 제한**까지 추가한 타입 시스템

```ts
let tuple1: [number] = [1]; // [1]은 튜플이 가질 수 있는 원소의 개수
let tuple2: [number, string, boolean] = [1, "hi", true]; // 여러 타입 혼합 가능
```

<br>

### 튜플 예시 ( React의 `useState` )

```jsx
import { useState } from "react";

const [value, setValue] = useState(false);
// 첫 번째 원소(data): 훅으로부터 생성 및 관리되는 상태 값을 의미
// 두 번째 원소(setData): 해당 상태를 조작할 수 있는 세터(setter)
```

<br>

## 6. enum 타입

: 열거형(enumerable), 타입스크립트에서 지원하는 특수 타입

- 일종의 구조체를 만드는 타입 시스템
    <details><summary>예제 1</summary> 
    ```ts
    enum ProgrammingLanguage {
        TS,
        JS,
        Java ,
        Python,
        Kotlin,
        Rust,
        Go
    }

  // 각 멤버에 접근하는 방식은 JS에서 객체 속성에 접근하는 방식과 동일
  ProgrammingLanguage.TS;
  ProgrammingLanguage.Rust;
  ProgrammingLanguage["Kotlin"];

  ProgrammingLanguage[3]; // 역방향으로도 접근 가능

  ````
  </details>

  <details><summary>예제 2</summary>

  ```ts
  enum ProgrammingLanguage {
      TS = "TypeScript",
      JS = "JavaScript",
      Java = 3,
      Python = 4,
      Kotlin = 400,
      Rust = 500,
      Go = 501
  }
  ````

  각 멤버에 명시적으로 값을 할당할 수 있음

    </details>

- enum 타입은 주로 **문자열 상수**를 생성하는 데 사용됨
    <details><summary>예제</summary>

  ```ts
  enum ItemStatusType {
    DELIVERY_HOLD = "DELIVERY_HOLD", // 배송 보류
    DELIVERY_READY = "DELIVERY_READY", // 배송 준비 중
    DELIVERING = "DELIVERING", // 배송 중
    DELIVERED = "DELIVERED", // 배송 완료
  }
  ```

    </details>

### 열거형 사용 시 주의할 점❗

숫자로만 이뤄져 있거나 타입스크립트가 자동으로 추론한 열거형은 안전하지 않은 결과를 낳을 수 있음.

```ts
enum ProgrammingLanguage {
  TS,
  JS,
  Java,
}

ProgrammingLanguage[7];
// 🚨 할당된 값을 넘어서븐 범위로 역방향으로 접근해도 타입스크립트는 막지 않음
```

<br>

### ✅ 위와 같은 동작을 막기 위해 `const enum`으로 열거형 선언

```ts
const enum ProgrammingLanguage {
  TS,
  JS,
  Java,
  Python,
  Kotlin,
  Rust,
  Go,
}

ProgrammingLanguage[200]; // 🚨 에러 발생
```

- 이렇게 하더라도 **숫자** 상수로 관리되는 열거형은 선언한 값 이외의 값을 할당하거나 접근할 때 이를 방지하지 못함
- 반면, **문자열** 상수 방식으로 선언한 열거형은 미리 선언하지 않은 멤버로 접근을 방지

<br>

### 결론

문자열 상수 방식 열거형을 사용하는 게 숫자 상수 방식보다 더 **안전**하며, **의도치 않은 값의 할당이나 접근을 방지하는 데 도움**이 됨

```ts
const enum Number {
  ONE = 1,
  TWO = 2,
}

const myNumber: Number = 100;
// Number enum에서 100을 관리하고 있지 않지만 에러 발생하지 않음

const enum STRING_NUMBER {
  ONE = "ONE",
  TWO = "TWO",
}

const myStringNumber: STRING_NUMBER = "THREE"; // 🚨 Error 발생
```

<br>
<br>

# `3.2` 타입 조합

<h2 style="color:#178c7c">1. 교차 타입(Intersection)</h2>
: 여러 가지 타입을 결합하여 **하나의 단일 타입**으로 만듦

<br>

```ts
type ProductItem = {
  id: number;
  name: string;
  type: string;
  price: number;
  imageUrl: string;
  quantity: number;
};

type ProductItemWithDiscount = ProductItem & { discountAmount: number };
// ProductItem의 모든 멤버와 discountAmount까지 멤버로 갖게 됨
```

<br>

<h2 style="color:#178c7c">2. 유니온 타입(Union)</h2>

```ts
type ProductItem = {
  id: number;
  name: string;
  type: string;
  price: number;
  imageUrl: string;
  quantity: number;
};

type CardItem = {
  id: number;
  name: string;
  type: string;
  imageUrl: string;
};

type ProductEventItem = ProductItem | CardItem;

const printPromotionItem = (item: ProductEventItem) => {
  console.log(item.name);

  console.log(item.quantity); // 컴파일 에러🚨
};
```

name은 두 타입 모두 갖고 있지만, quantity는 ProductItem 타입만 가지고 있기 때문에 참조 불가능

<br>

<h2 style="color:#178c7c">3. 인덱스 시그니처(Index Signatures)</h2>

> 특정 타입의 속성 이름은 알 수 없지만 속성값의 타입을 알고 있을 때 사용

```ts
interface IndexSignatureEx {
  [key: string]: number;
}
// 키는 string 타입, 값은 모두 number 타입이어야 함을 의미
```

다른 속성을 추가로 명시해줄 수 있는데, 추가로 명시된 속성은 **인덱스 시그니처에 포함되는 타입**이어야 함.

<br>

<h2 style="color:#178c7c">4. 인덱스드 엑세스 타입(Indexed Access Types)</h2>

> 다른 타입의 특정 속성이 가지는 타입을 조회하기 위해 사용됨.

```ts
type Example = {
  a: number;
  b: string;
  c: boolean;
};

type IndexedAccess = Example["a"];
type IndexedAccess2 = Example["a" | "b"];
type IndexedAccess3 = Example[keyof Example];

type ExAlias = "b" | "c";
type IndexedAccess4 = Example[ExAlias];
```

<br>

또한 배열의 요소 타입을 조회하기 위해 사용하는 경우도 있음.

```ts
const PromotionList = [
  { type: "product", name: "chicken" },
  { type: "product", name: "pizza" },
  { type: "card", name: "cheer-up" },
];

type ElementOf<T> = (typeof T)[number];

// type PromotionItemType = { type: string; name: string; }
type PromotionItemList = ElementOf<PromotionList>;
```

<br>

<h2 style="color:#178c7c">5. 맵드 타입(Mapeed Types)</h2>

> 보통 map은, 유사한 형태를 가진 여러 항목의 목록 A → 변환된 항목의 목록 B로 바꾸는 것 의미<br> 맵드 타입은 다른 타입을 기반으로 한 타입을 선언할 때 사용하는 방법

```ts
type Example = {
  a: number;
  b: string;
  c: boolean;
};

type Subset<T> = {
  [K in keyof T]?: T[K];
};

const aExample: Subset<Example> = { a: 3 };
const bExample: Subset<Example> = { b: "hello" };
const cExample: Subset<Example> = { a: 4, c: true };
```

<br>

- `readonly` : 읽기 전용으로 만들고 싶을 때
- `?` : 선택적 매개변수(Optional Parameter)
- `-` : 해당 수식어를 제거

```ts
type ReadOnlyEx = {
  readonly a: number;
  readonly b: string;
};

type CreateMutable<Type> = {
  -readonly [Property in keyof Type]: Type[Property];
};

type ResultTypeA = CreateMutable<ReadOnlyEx>; // { a: number, b: string }

type OptionalEx = {
  a?: number;
  b?: string;
  c: boolean;
};

type Concrete<Type> = {
  [Property in keyof Type]-?: Type[Property];
};

type ResultTypeB = Concrete<OptionalEx>; // { a: number; b: string; c: boolean }
```

<br>
<h2 style="color:#178c7c">6. 템플릿 리터럴 타입(Template Literal Types)</h2>

```ts
type Stage =
  | "init"
  | "select-image"
  | "edit-image"
  | "decorate-card"
  | "capture-image";

type StageName = `${Stage}-stage`;
// 'init-stage' | "select-image-stage" | "edit-image-stage" | "decorate-card-stage" | "capture-image-stage";
```

<br>

<h2 style="color:#178c7c">7. 제네릭(Generic)</h2>

> C, Java 같은 정적 언어에서 다양한 타입 간에 재사용성을 높이기 위해 사용하는 문법<br><br>
> 함수, 타입, 클래스 등에서 내부적으로 사용할 타입을 미리 정해두지 않고 타입 변수를 사용해서 해당 위치를 비워 둔 다음, 실제로 그 값을 사용할 때 외부에서 타입 변수 자리에 타입을 지정하여 사용하는 방식

- 이렇게 하면 함수, 타입, 클래스 등 여러 타입에 대해 하나하나 따로 정의하지 않아도 되어 **재사용성이 크게 향상**
- 보통 타입 변수명으로 `T(Type)`, `E(Element)`, `K(Key)`, `V(Value)` 등 한 글자로 된 이름을 많이 사용

```ts
type ExampleArrayType<T> = T[];

const array: ExampleArrayType<string> = ["치킨", "피자", "햄버거"];
```

<br>

제네릭이 일반화된 데이터 타입을 의미한다고 했는데, 이렇게 보면 any의 쓰임과 혼동할 수도 있지만 **둘은 명확히 다름.**

둘의 차이는 배열을 통해 쉽게 알 수 있는데, any 타입의 배열에서는 배열 요소들의 타입이 전부 같지 않을 수 있음. 쉽게 말해 **타입 정보를 잃어버린다고 생각**하면 편함. 즉, any를 사용하면 타입 검사를 하지 않고 모든 타입이 허용되는 타입으로 취급됨.

반면 제네릭은 any처럼 아무 타입이나 받는 게 아니라, 배열 생성 시점에 원하는 타입으로 특정할 수 있음. 즉, 제네릭을 사용하면 **배열 요소가 전부 동일한 타입이라고 보장**할 수 있음.

<br>

참고로 제네릭 함수 호출 시 반드시 `꺽쇠괄호(<>)` 안에 타입을 명시해야 하는 것은 아님. <br>
이 부분을 생략하면 컴파일러가 인수를 보고 타입을 추론해줌. <br>= 타입 추론이 가능한 경우에는 타입 명시 생략 가능

```ts
function exampleFunc<T>(arg: T) {
  return new Array(3).fill(arg);
}

exampleFunc("hello"); // T는 string으로 추론됨
```

<br>

또한 특정 요소 타입을 알 수 없을 때는 제네릭 타입에 **기본값**을 추가할 수 있음.

```ts
interface SubmitEvent<T = HTMLElement> extends SyntheticEvent<T> {
  submitter: T;
}
```

<br>
제네릭은 일반화된 데이터 타입을 의미. 따라서 함수나 클래스 등의 내부에서 제네릭을 사용할 때, 어떤 타입이든 될 수 있다는 개념을 알고 있어야 함.

<br>
<br>

# `3.3` 제네릭 사용법

<h2 style="color:#178c7c">1. 함수의 제네릭</h2>

> 어떤 함수의 매개변수나 반환 값에 다양한 타입을 넣고 싶을 때 사용

```ts
function ReadOnlyRepository<T>(
  target: ObjectType<T> | EntitySchema<T> | string
): Repository<T> {
  return getConnection("ro").getRepository(target);
}
```

<br>
<h2 style="color:#178c7c">2. 호출 시그니처의 제네릭</h2>

> **호출 시그니처(call signature)**<br>: 타입스크립트의 함수 타입 문법으로, 함수의 매개변수와 반환 타입을 미리 선언하는 것

<br>

<h2 style="color:#178c7c">3. 제네릭 클래스</h2>

> 외부에서 입력된 타입을 클래스 내부에 적용할 수 있는 클래스

클래스 이름 뒤에 타입 매개변수인 `<T>`를 선언해줌. 제네릭 클래스를 사용하면 클래스 전체에 걸쳐 타입 매개변수가 적용됨. 특정 메서드만을 대상으로 제네릭을 적용하려면 해당 메서드를 제네릭 메서드로 선언하면 됨.

<br>

<h2 style="color:#178c7c">4. 제한된 제네릭</h2>

> 타입 매개변수에 대한 제약 조건을 설정하는 기능

예를 들어 string 타입으로 제약하려면 타입 매개변수는 특정 타입을 상속(extends)해야 함.

```ts
type ErrorRecord<Key extends string> = Exclude<
  KeyAlgorithm,
  ErrorCodeType
> extends never
  ? Partial<Record<Key, boolean>>
  : never;
```

이처럼 타입 매개변수가 특정 타입으로 묶였을 때(bind) 키를 바운드 타입 매개변수(bounded type parameters)라고 부름. 그리고 string을 키의 상한 한계(upper bound)라고 함.

<br>
<h2 style="color:#178c7c">5. 확정된 제네릭</h2>

> 여러 타입을 상속받을 수 있으며 타입 매개변수를 여러 개 둘 수 있음.

```ts
<Key extends string>
```

이런 식으로 제약해버리면 제네릭의 유연성을 잃어버림

<br>

```ts
<Key extends string | number>
```

유연성을 잃지 않으면서 타입을 제약해야 할 때는 타입 매개변수에 유니온 타입을 상속해서 선언하면 됨.

<br>

<h2 style="color:#178c7c">6. 제네릭 예시</h2>

> **제네릭의 장점** : 다양한 타입을 받게 함으로써 코드를 효율적으로 재사용할 수 있는 것<br>
> 실제 현업에서 가장 많이 제네릭이 활용될 때 = `API 응답 값의 타입`을 지정할 때

#### 예제

```ts
export interface MobileApiResponse<Data> {
  data: Data;
  statusCode: string;
  statusMessage?: string;
}
// API 응답 값에 따라 달라지는 data를 제네릭 타입 Data로 선언

export const fetchPriceInfo = (): Promise<MobileApiResponse<PriceInfo>> => {
  const priceUrl = "https: ~~~"; // url 주소

  return request({
    method: "GET",
    url: priceUrl,
  });
};

export const fetchOrderInfo = (): Promise<MobileApiResponse<Order>> => {
  const orderUrl = "https: ~~~"; // url 주소

  return request({
    method: "GET",
    url: orderUrl,
  });
};
```

<br>

### 제네릭을 굳이 사용하지 않아도 되는 타입

```ts
type GType<T> = T;
type RequirementType = "USE" | "UN_USE" | "NON_SELECT";

interface Order {
  getRequirement(): GType<RequirementType>;
}
```

> GType이 다른 곳에서는 사용되지 않고 getRequirement 함수의 반환 값 타입으로만 사용되고 있다고 가정.

GType이라는 이름이 현재 사용되고 있는 목적의 의미를 정확히 담고 있지도 않을뿐더러,<br>
굳이 제네릭을 사용하지 않고 타입 매개변수를 그대로 선언하는 것과 같은 기능을 하고 있음.

<br>

즉, 아래처럼 사용되는 것과 동일

```ts
type RequirementType = "USE" | "UN_USE" | "NON_SELECT";

interface Order {
  getRequirement(): RequirementType;
}
```

<br>

### any 사용하기

> 제네릭은 코드 재사용성을 높이고 타입 추론을 하는 데 사용됨.

그러나 any를 사용하면 제네릭의 장점 + 타입 추론 및 타입 검사를 할 수 있는 이점을 누릴 수 없게 됨.
any를 사용하면 제네릭을 포함해 타입을 지정하는 의미가 X

<br>

### 가독성을 고려하지 않은 사용

제네릭이 과하게 사용되면 가독성을 해쳐 코드를 읽고 타입을 이해하기 어려워짐.<br>
부득이한 상황을 제외하고 복잡한 제네릭은 의미 단위로 분할해서 사용하는 게 👍
