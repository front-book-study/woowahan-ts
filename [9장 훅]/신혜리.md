## 9.1 ] 리액트 훅

---

- 클래스 컴포넌트에서는 하나의 생명주기 함수에서만 상태 업데이트에 따른 로직을 실행할 수 있어서 로직을 분리하기가 어려웠음. ⇒ 유지보수 및 디버깅에 어려움
- 함수형 컴포넌트에서도 훅을 이용하여 상태 업데이트를 실행할 수 있게 되면서 비즈니스 로직을 작은 단위로 분리하여 재사용성이나 테스트가 용이, 관심사에 맞게 분리하여 구성할 수 있게 되었음

![Screenshot 2025-09-28 at 12.03.46 PM.png](attachment:bb696084-a2b9-4e70-98a5-72d20a10e6fd:Screenshot_2025-09-28_at_12.03.46_PM.png)

### 1. useState

- 반환값은 튜플 :
  - 제네릭으로 지정한 S 타입
  - 상태를 업데이트할 수 있는 Dispatch 함수

```tsx
function useState<S>(
	initialState: S | () => S
): [S, Dispatch<SetStateAction<S>>];

type Dispatch<A> = (value: A) => void;
type SetStateAction<S> = S | (prevState:S) => S;
```

- useState에 타입스크립트를 적용
  - 전 : 잘못된 속성이 포함된 객체를 추가해서 setState를 호출해도 에러가 발생하지 않음
    → 잘못들어간 값 때문에 런타임에서 사이드 이팩트 발생
  - 후 : 잘못된 속성이 포함된 객체를 추가하면 setState 호출시 컴파일 타임에 에러 발생

```tsx
const [memberList, setMemberList] = useState<Member[]>([]);
```

### 2. 의존성 배열을 사용하는 훅

`useEffect`

```tsx
function useEffect(effect: EffectCallback, deps?: DependencyList): void;

type DependencyList = ReadonlyArray<any>;
type EffectCallback = () => void | Destructor;
```

- EffectCallback : effect의 타입. Destructor 반환하거나 아무것도 반환하지 않는 함수
  - Promise 타입은 반환하지 않으므로 useEffect의 콜백함수에는 비동기 함수 들어갈 수 없음
    - useEffect에서 비동기 함수를 호출 할 수 있다면 경쟁 상태 (Race Condition) 불러일으킬 수 있기 때문
    - 경쟁상태 = 멀티스트레딩 환경에서 동시에 여러 프로세스나 스레드가 공유된 자원에 접근하려고 할 때 발생할 수 있는 문제. 이러한 상황에서 실행 순서나 타이밍을 예측할 수 없게 되어 프로그램 동작이 원하지 않는 방향으로 흐를 수 있음
  - Destructor는 컴포넌트가 마운트 해제될 때 실행하는 함수.
    - deps = [] : useEffect의 콜백 함수는 컴포넌트가 처음 렌더링될 때만 실행. Destructor는 컴포넌트가 마운트 해제될 때 실행
    - deps ≠ [] : 배열의 값이 변경될 때마다 Destructor가 실행됨
- deps : 옵셔녈하게 제공. effect가 수행되기 위한 조건 나열.
  - deps의 원소로 숫자나 문자열 같은 타입스크립트 기본 자료형이 아닌 객체나 배열을 넣을 때 주의 필요.
  - deps가 변경되었는지를 **얕은 비교**로만 판단하기 때문에 실제 객체 값이 바뀌지 않았더라도 객체의 참조 값이 변경되면 콜백 함수 실행
  - 얕은 비교 = 객체나 배열과 같은 복합 데이터 타입의 값을 비교할 떄 내부의 각 요소놔 속성을 재귀적으로 비교하지 않고 해당 값들의 참조나 기본 타입 값만을 간단하게 비교하는 것

```tsx
useEffect(() => {
  //value.name, value.id 사용
}, [value]);
```

```tsx
const { id, name } = value;

useEffect(() => {
  //value.name, value.id => name, id 직접 사용
}, [id, name]);
```

\*\* 클린업 함수 : useEffect나 useLayoutEffect와 같은 리액트 훅에서 사용되며, 컴포넌트가 해제되기 전에 정리 작업을 수행하기 위한 함수를 뜻함.

`useLayoutEffect`

- useEffect와 타입, 사용방법은 동일
- 차이점은 실행 시점에 있음
  - useEffect : render 함수 실행 이후에 실행됨
  - useLayoutEffect : render 함수 이전에 실행됨

`useMemo / useCallback`

- 이전에 생성된 값, 함수를 기억하며 동일한 값과 함수를 반복해서 생성하지 않도록 해주는 훅
- 값을 계산하는데 오랜 시간이 걸릴 때, 렌더링이 자주 발생하는 form에서 유용하게 사용

- 두 훅 모두 제네릭 지원
  - useCallback : 함수 저장하기 위해 제네릭의 기본 타입 지정 (extends 사용\_
- 두 훅 모두 useEffect 의존성 배열과 같은 주의사항

```tsx

```

### useRef

- DOM에 직접 접근하려고 할 때 사용

- 3 종류의 타입 정의
- useRef에 넣어주는 인자 타입에 따라 반환되는 타입이 달라짐
- useRef는 MutableObject / RefObject를 반환

```tsx

```

## 9.2 ] 커스텀 훅

---

- 커스텀 훅은 이름이 반드시 use로 시작해야 함.
- 타입은 유추하기 힘들때 IDE 활용하자
