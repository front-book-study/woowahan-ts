## 9.1 리액트 훅

리액트 훅이 도입되면서 함수 컴포넌트에서도 클래스 컴포넌트와 같이 컴포넌트의 생명주기에 맞춰 로직을 실행할 수 있게 되었다.
-> 이를 통해 1) 비즈니스 로직을 재사용하거나 2) 작은 단위로 코드를 분할하여 테스트하는 게 용이해졌으며 3) 사이드 이펙트와 상태를 관심사에 맞게 분리하여 구성할 수 있게 되었다.

### 9.1.1 useState
```
function useState<S>(inintalSTate: S | (() => S)) : [S, Dispatch<SetStateAction<S>>];

type Dispath<SetStateACtion<S>>];
type SetStateAction<S> = S | ((prevState: S) => S);
```

useState가 반환하는 튜플을 살펴보면
튜플의 첫 번째 요소는 제네릭으로 지정한 S타입이며, 두 번째 요소는 상태를 업데이트할 수 있는  Dispatch 타입의 함수이다.
Dispatch함수의 제네릭으로 지정한 `SetStateAction`에는 useState로 관리할 상태 타입인 S 또는 이전 상태 값을 받아 새로운 상태를 반환하는 함수인 (prevState:S) => S 가 들어갈 수 있다.
이처럼 useState를 동기적으로 처리하기 위해 사용한다

?? useState는 비동기로 실행한다고 알고 있는데.. gpt에 물어봄
https://chatgpt.com/share/68d7ea61-319c-8001-a1dc-ffe21b23727d


### 9.1.2 의존성 배열을 사용하는 훅
#### useEffect와 useLayoutEffect
```
function useEffect(effect:EffectCallback, deps?: DependencyList): void;
type DependencyList = ReadonlyArray<any>;
type EffectCallback = () => void | Destructor;
```

useEffect의 첫 번째 인자이자 effect의 타입인 EffectCallback은 Destructor를 반환하거나 아무것도 반환하지 않는 함수이다. Promise 타입은 반환하지 않으므로 useEffect의 콜백 함수에는 비동기 함수가 들어갈 수 없다. 
=> useEffect에서 비동기 함수를 호출할 수 있다면 경쟁 상태를 불러일으킬 수 있기 때문이다. 
> 경쟁상태 : 멀티스레딩 환경에서 동시에 여러 프로세스나 스레드가 공유된 자원에 접근하려고 할 때 발생할 수 있는 문제.

두 번째 인자인 deps는 옵셔널하게 제공되며 effect가 수행되기 위한 조건을 나열한다. 
다만 deps의 원소로 숫자나 문자열같은 기본 자료형이 아닌 객체나 배열을 넣을 때는 주의해야한다. 
-> 변경에 대해 얕은 비교로 판단하기 때문에, 실제 객체 값이 바뀌지 않더라도 객체의 참조 값이 변경되면 콜백 함수가 실행된다. 
-> 원치 않은 렌더링이 반복될 수 있다.
-> 이를 방지하기 위해 실제로 사용하는 값을 useEffect의 deps에서 직접 사용해야한다.


#### useMemo와 useCallback
이전에 생성된 값 또는 함수를 기억하며, 동일한 값과 함수를 반복해서 생성하지 않도록 해주는 훅
```
type DependencyList = ReadonlyArray<any>;

function useMemo<T>(factory: () => T, deps: DependencyLsit | undefined):T;
function useCallback<T extends (...args: any[]) => any>(callback: T, deps: DependencyList): T;
```
두 훅 모두 제네릭을 지원하기 위해 T 타입을 선언해주며 useCallback은 함수를 저장하기 위해 제네릭의 기본 타입을 지정하고 있다. 두 훅은 deps 배열을 가지고 있으며 useEffect와 같은 주의사항이 있다. 

### 9.1.3 useRef
DOM을 직접 선택해야하는 경우가 있을 때 사용한다.
```
//HTMLInputElement | null 로 제네릭 설정을 하지 않았는데 초기 설정값을 null로 넣을 수 있을까?
const ref = useRef<HTMLInputElement>(null)
```
useRef는 세 종류의 타입 정의를 가지고 있다. useRef에 넣어주는 인자 타입에 따라 반환되는 타입이 달라진다.
```
function useRef<T>(initalValue: T): MutableRefObject<T>;
function useRef<T>(inital:T | null): RefObject<T>;
function useRef<T = undefined>(): MutableRefObject<T|undefined>;

interface MutableRefObject<T> {
    current: T;
}

interface RefObject<T>{
    readonly current: T | null;
}
```
useRef는 MutableRefObject 또는 RefObject를 반환한다. 
MutrableRefObject의 current는 값을 변경할 수 있다. 만약 null을 허용하기 위해 useRef의 제네릭에 HTMLInputElement | null 타입을 넣어주었다면 해당 useRef는 첫 번째타입 정의(function useRef<T>(initalValue: T): MutableRefObject<T>;)를 따를 것이다. 
이때 MutableObject의 current는 변경할 수 있는 값이 되어 ref.current의 값이 바뀌는 사이드 이펙트가 발생할 수 있다.
반면 RefObject의 current는 readonly로 값을 변경할 수 없다. 앞의 예시에서는 useRef의 제네릭으로 HTMLInputElement를 넣고, 인자에 null을 넣어 useRef의 구번째 타입정의 (function useRef<T>(initialValue: T | null): RefObject<T>)를 따르게 된다. 이러면 RefObject를 반환하여 ref.current 값을 임의로 변경할 수 없게 된다.

- DOM에 주입할 ref: useRef<엘리먼트타입>(null) → 읽기 전용 RefObject 
    - React가 current 관리
- 내가 값 들고 있을 ref: useRef<T>(초기값) or useRef<T>() → 쓰기 가능한 MutableRefObject
  - setTimeout ID, 이전 값 저장, 스크롤 위치 캐시, 비동기 flag.. 
  
=> HTMLInputElement | null를 제네릭에 넣지 말고, 인자에만 null을 넣자. (React 소유 패턴 유지)

#### 자식 컴포넌트에 ref 전달하기
ref를 일반적인 props 넘기기 방법으로 넘기면 경고메세지가 발생한다. 
ref라는 속성의 이름은 리액트에서 `DOM 요소 접근`이라는 특수한 목적으로 사용되기 때문에 props를 넘겨주는 방식으로 전달할 수 없다. 리액트 컴포넌트에서 ref를 prop으로 전달하기 위해서는 `forwardRef`를 사용해야한다. 

```
type ForwardedRef<T> = 
| ((instance: T | null) => void)
| MutableRefObject<T | null>
| null;
```
ForwardRef에는 오직 MutableRefObject만 들어올 수 있다. MutableRefObject가 refObject보다 넓은 범위의 타입을 가지기 때문에, 부모 컴포넌트에서 ref를 어떻게 선언했는지와 관계없이 자식 컴포넌트가 해당 ref를 수용할 수 있다.


#### useRef의 여러 가지 특성
- useRef로 관리되는 변수는 값이 변경되더라도 컴포넌트의 리렌더링이 발생하지 않는다. 이런 특성을 활용하면 상태가 변경되더라도 불필요한 리렌더링을 피할 수 있다. 
- 리액트 컴포넌트의 상태는 상태 변경함수를 호출하고 렌더링된 이후에 업데이트된 상태를 조회할 수 있다. 반면 useRef로 관리되는 변수는 값을 설정한 후 즉시 조회할 수 있다. 
