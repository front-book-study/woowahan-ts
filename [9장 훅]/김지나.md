## 9.1 리액트 훅

리액트 훅이 도입되면서 함수 컴포넌트에서도 클래스 컴포넌트와 같이 컴포넌트의 생명주기에 맞춰 로직을 실행할 수 있게 되었다.
-> 이를 통해 1) 비즈니스 로직을 재사용하거나 2) 작은 단위로 코드를 분할하여 테스트하는 게 용이해졌으며 3) 사이드 이펙트와 상태를 관심사에 맞게 분리하여 구성할 수 있게 되었다.

### 9.1.1 useState
```
function useState<S>(inintalSTate: S | (() => S)) : [S, Dispatch<SetStateAction<S>>];

type Dispath<SetStateACtion<S>>];
type SetStateAction<S> = S | ((prevState: S) => S);
```

useState가 반환하는 튜플을 살펴보면
튜플의 첫 번째 요소는 제네릭으로 지정한 S타입이며, 두 번째 요소는 상태를 업데이트할 수 있는  Dispatch 타입의 함수이다.
Dispatch함수의 제네릭으로 지정한 `SetStateAction`에는 useState로 관리할 상태 타입인 S 또는 이전 상태 값을 받아 새로운 상태를 반환하는 함수인 (prevState:S) => S 가 들어갈 수 있다.
이처럼 useState를 동기적으로 처리하기 위해 사용한다

?? useState는 비동기로 실행한다고 알고 있는데.. gpt에 물어봄
https://chatgpt.com/share/68d7ea61-319c-8001-a1dc-ffe21b23727d


### 9.1.2 의존성 배열을 사용하는 훅
#### useEffect와 useLayoutEffect
```
function useEffect(effect:EffectCallback, deps?: DependencyList): void;
type DependencyList = ReadonlyArray<any>;
type EffectCallback = () => void | Destructor;
```

useEffect의 첫 번째 인자이자 effect의 타입인 EffectCallback은 Destructor를 반환하거나 아무것도 반환하지 않는 함수이다. Promise 타입은 반환하지 않으므로 useEffect의 콜백 함수에는 비동기 함수가 들어갈 수 없다. 
=> useEffect에서 비동기 함수를 호출할 수 있다면 경쟁 상태를 불러일으킬 수 있기 때문이다. 
> 경쟁상태 : 멀티스레딩 환경에서 동시에 여러 프로세스나 스레드가 공유된 자원에 접근하려고 할 때 발생할 수 있는 문제.

두 번째 인자인 deps는 옵셔널하게 제공되며 effect가 수행되기 위한 조건을 나열한다. 
다만 deps의 원소로 숫자나 문자열같은 기본 자료형이 아닌 객체나 배열을 넣을 때는 주의해야한다. 
-> 변경에 대해 얕은 비교로 판단하기 때문에, 실제 객체 값이 바뀌지 않더라도 객체의 참조 값이 변경되면 콜백 함수가 실행된다. 
-> 원치 않은 렌더링이 반복될 수 있다.
-> 이를 방지하기 위해 실제로 사용하는 값을 useEffect의 deps에서 직접 사용해야한다.


#### useMemo와 useCallback
이전에 생성된 값 또는 함수를 기억하며, 동일한 값과 함수를 반복해서 생성하지 않도록 해주는 훅
```
type DependencyList = ReadonlyArray<any>;

function useMemo<T>(factory: () => T, deps: DependencyLsit | undefined):T;
function useCallback<T extends (...args: any[]) => any>(callback: T, deps: DependencyList): T;
```
