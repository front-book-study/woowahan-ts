## 1. useState

## 2. useEffect와 useLayoutEffect

```tsx
function useEffect(effect: EffectCallback, deps?: DependencyList): void;
type DependencyList = ReadonlyArray<any>;
type EffectCallback = () => void | Destructor;
```

`effect: EffectCallback`

콜백 함수에는 비동기 함수가 들어갈 수 없다. 

- `EffectCallback` 의 타입을 보다시피, `Promise` 를 반환하지 않는다.
- useEffect에서 비동기 함수를 호출할 수 있다면 경쟁 상태를 불러일으킬 수 있기 떄문에

`deps?: DependencyList`

주의할 점

- 참조타입(객체, 배열)을 넣으면, useEffect는 deps의 변경 기준을 얕은 비교로만 판단하기 떄문에, 실제 객체 값이 바뀌지 않아도 참조값 변경 시 콜백함수 실행
    
    ```tsx
    const { id, name } = value;
    
    useEffect(() => {
      // value.name과 value.id 대신 name, id를 직접 사용한다
    }, [id, name]);
    ```
    
    위 코드와 같이 사용해야함.
    
    - 이런 특징은 useMemo, useCallback과 같은 다른 훅에서도 동일하게 적용

## 3. useRef

<aside>

⚠️ **가능한 한 적게 사용**해야 하는 "escape hatch"

</aside>

```tsx
function useRef<T>(initialValue: T): MutableRefObject<T>;
function useRef<T>(initialValue: T | null): RefObject<T>;
function useRef<T = undefined>(): MutableRefObject<T | undefined>;

interface MutableRefObject<T> {
  current: T;
}

interface RefObject<T> {
  readonly current: T | null;
}
```

useRef는 세 종류의 타입정의를 가짐

- 넣어주는 인자 타입에 따라 반환되는 타입이 달라진다.

### useImperativeHandler

- 자식의 특정 동작을 부모가 트리거해야 할 때
- DOM 조작이 필요할 때 (포커스, 스크롤 등)
- 써드파티 라이브러리와의 통합
