## 8.2 리액트 컴포넌트의 타입
### 8.1.1 클래스 컴포넌트 타입
```
import { ComponentLifecycle } from 'react';

interface Component<P = {}, S = {}, SS = any>
  extends ComponentLifecycle<P, S, SS> {}

class Component<P, S> {}

class PureComponent<P = {}, S = {}, SS = any> extends Component<P, S, SS> {}
interface WelcomProps {
  name: string;
}

class Welcome extends React.Component<WelcomProps> {
  // 생략
}
```
### 8.1.2 함수 컴포넌트 타입
```
//함수 선언을 사용
function Welcome(props: WelcomeProps): JSX.Element {
  return <div></div>;
}

// 함수 표현식을  사용한 방식 3가지
const Welcome2: React.FC<WelcomeProps> = ({ name }) => {
  return <div></div>;
};

const Welcome3: React.VFC<WelcomeProps> = ({ name }) => {
  return <div></div>;
};

const Welcome4 = ({ name }: WelcomeProps): JSX.Element => {
  return <div></div>;
};
```
18v에서는 VFC가 사라지고, FC의 기본 옵션이 children 있음에서 없음으로 변경되었다.

### 8.1.3 Children props 타입 지어
```
type PropsWithCildren<P> = P & { children?: ReactNode | undefined };
```
ReactNode는 ReactElement 외에도 boolean, number 등 여러 타입을 포함하고 있는 타입으로, 더 구체적으로 타이핑하는 용도에는 적합하지 않다. 예를들어 특정 문자열만 허용하고 싶을 때는 children에 대해 추가로 타이핑해주어야 한다. 


### 8.1.4 render 메서드와 함수 컴포넌트의 반환 타입 - React.ReactElement vs JSX.Element vs React.ReactNode

JSX.Element  <  React.ReactElement  < React.ReactNode   ( 포함관계)

```
declare global {
  namespace JSX {
    interface Element extends React.ReactElement<any, any> {}
  }
}
```

JSX.Element 타입은 위의 코드를 보면 알 수 있듯이 ReactElement를 확장하고 있는 타입이며, 글로벌 네임스페이스에 정의되어 있어 외부 라이브러리에서 컴포넌트 타입을 재정의 할 수 있는 유연성을 제공한다.

JSX.Element는 ReactElement의 특정 타입으로 props와 타입 필드를 any 로 가지는 타입이다.

리액트 엘리먼트를 prop으로 전달받아 render props 패턴으로 컴포넌트를 구현할 때 유용하다.

```
interface ReactElement<P = any,
    T extends strung | JSXElementConstructor<any> = 
    | string
    | JSXElementConstructor<any>
>{
    type: T;
    props:P;
    key: Key | null;
}
```
React.createElement를 호출하는 형태의 구문으로 변환하면 React.createElement의 반환 타입은 ReactElement이다. 리액트는 실제 DOM이 아니라 가상의 DOM을 기반으로렌더링하는데 가상 DOM의 엘리먼트는 ReactElement 형태로 저장된다. 
**ReactElement 타입은 리액트 컴포넌트를 객체 형태로 저장하기 위한 포맷이다. **

```
type ReactText = string | number;
type ReactChild = RactElement | ReactText;
type ReactFragment = {} | Iterable<ReactNode>;

type ReactNode = 
    | ReactChild
    | ReactFragment
    | RactPortal
    | boolean
    | null
    | undefined;
```
ReactNode는 리액트의 render함수가 반환할 수 있는 모든 형태를 담고 있다.

따라서 prop으로 리액트 컴포넌트가 다양한 형태를 가질 수 있게 하고 싶을 때 유용하게 사용된다.

HTML 태그의 속성 타입을 활용하는 대표적인 2가지 방법은 `DetailedHTMLProps` 와 `ComponentWithoutRef`가 있다.

차이점은 ref의 포함 유무이다.

```
//DetailedHTMLProps
type NativeButtonProps = React.DetailedHTMLProps<
  React.ButtonHTMLAttributes<HTMLButtonElement>,
  HTMLButtonElement
>;

type ButtonProps = {
  onClick?: NativeButtonProps['onClick'];
};

//ComponentWithoutRef
type NativeButtonType2 = React.ComponentPropsWithoutRef<'button'>;
type ButtonProps2 = {
  onClick?: NativeButtonType2['onClick'];
};
```
함수 컴포넌트의 props로 DetailedHTMLProps와 같이 ref를  포함하는 타입을 사용하게 되면, 실제로는 동작하지 않는 ref를 받도록 타입이 지정되어 예기치 않은 에러가 발생할 수 있다

따라서 HTML 속성을 확장하는 props를 설계할 때는 ComponentPRopsWithoutRef 타입을 사용하여 ref가 실제로 forwardRef와 함께 사용할 때만 props로 전달되도록 타입을 정의하는 것이 안전하다.

## 8.2 타입스크립트로 리액트 컴포넌트 만들기
### 8.2.1 JSX로 구현된 컴포넌트
JSX로 만든 컴포넌트에 각 속석에 어떤 타입의 값을 전달해야할지 명확히 알 수없는 문제가 생김

### 8.2.2 JSDocs로 일부 타입 지정하기
컴포넌트의 속성 타입을 명시 ( 컴포넌트 설명 + 속성의 역할 )
```
/**
* Select 컴포넌트
*@param {Object} props - Select 컴포넌트로 넘겨주는 속성
*@param {Object} props.options - { [key: string]: string } 형식으로 이루어진 option 객체
lement)
const Select = //...
**/
```
### 8.2.3 props 인터페이스 적용하기
JSDocs를 사용하명 각 속성의 대략적인 타입과 어떤 역할을 파악할 수 있지만 options가 어떤 형식의 객체를 나타내는지나 onChange의 매개변수 및 반환값에 대한 구체적인 정보를 알기 쉽지 않아 잘못된 타입이 전달될 수 있는 위험이 있다. 
-> 이러한 문제를 해결하기 위해 타입스크립트(tsx)를 사용하여 좀 더 정교하고 구체적인 타입 지적이 가능하다. 

### 8.2.4 리액트 이벤트
리액트는 가상 DOM을 다루면서 이벤트도 별도로 관리한다. onclick, onchange와 같이 DOM 엘리먼트에 등록되어 처리하는 이벤트 리스너와 달리, 리액트 컴포넌트(노드)에 등록되는 이벤트 리스터는 onClick, onChange처럼 `카멜케이스`로 표기한다.
-> 리액트 이벤트는 브라우저의 고유한 이벤트와 완전히 동일하게 동작하지는 않는다. 

예를들어 리액트 이벤트 핸들러는 이벤트 버블링 단계에서 호출된다.
이벤트 캡처 단계에서 이벤트 핸들러를 등록하기 위해서는 onClickCapture, onChangeCapture와 같이 일반 이벤트 리스너 이름 뒤에 Capture를 붙여야한다.

> 브라우저 이벤트 발생단계: 캡처 -> 타겟 -> 버블링

또한 리액트 브라우저 이벤트를 합성한 합성 이벤트를 제공한다. 
> 합성 이벤트: 브라우저 마다 다른 이벤트 동작을 통일하기 위한 것

```
type EventHandler<Event extends React.SyntheticEvent> = (e: Event) => void | null;
type ChangeEventHandler = EventHandler<ChangeEvent<HTMLSelectElement>>;

const eventHandler1: GlobalEventHandlers["onchange"] = (e) => {
    e.target; // 일반 이벤트는 target이 없음 
     // e의 타입: Event | null
    // TypeScript는 target 속성을 인식하지 못함
}

const eventHandler2: ChangeEventHandler = (e) => {
    e.target; // 리액트 이벤트(합성 이벤트)는 target이 있음
     // e의 타입: ChangeEvent<HTMLSelectElement>
    // TypeScript가 target을 완벽하게 인식
}
```

### 8.2.5 훅에 타입 추가하기
usState 같은 함수 역시 타입 매개변수를 지정해줌으로써 반환되는 state타입을 지정해줄 수 있다. 만약 제네릭 타입을 명시하지 않으면 타입스크립트 컴파일러는 초깃값의 타입을 기반으로 state 타입을 추론한다. 

```
const fruits = {
apple: "사과", banana: "바나나", blueberry: "블루베리",};

const FruitSelect: VFC = () => {
const [fruit, changeFruit] = useState‹string | undefined>();

return (<Select onChange={changeFruit} options={fruits} selectedOption={fruit} />
  );
};
// 만약 타입 매개변수가 없다면 fruit의 타입이 undefined로만 추론되어서 onChange의 타입과 일치하지 않아 오류가 발생
// fruit: undefined;
// changeFruit: (v: React.SetStateAction<undefined>) => void;
const [fruit, changeFruit] = useState();

return (
...
);
```

useState에 제네릭 타입을 지정해주지 않는다면 타입스크립트 컴파일러는 fruit를 string으로 추론, 다음에 다른 개발자가 changeFruit에 fruit 타입에 속하지 않는 orange를 넣을 수 있음.
-> 컴파일러 역시 이를 에러로 잡지 않아 예상치 못한 사이드 이펙트 발생 가능

이럴 때는 타입 매개변수로 좀 더 명확한 타입을 지정함으로써 다른 개발자가 해당 state나 changeState를 한정된 타입으로 다룰 수 잇게 강제할 수 있다.

### 8.2.6 제네릭 컴포넌트 만들기
```
const FruitSelect = () => {
const [fruit, changeFruit] = useState<Fruit | undefined>();

return (
<Select onChange={changeFruit} options={fruits} selectedOption="orange" />
  );
};
```

selectOption은 options에 존재하지 않는 값을 받아도 아무런 오류가 발생하지 않는다. 하지만 changeFruit의 매개변수 Fruit는 prop으로 전달되어야 하는 onChange 매개변수 string보다 좁기 때문에 에러가 발생한다. 
-> Select를 사용하는 입장에서 제한된 키와 값을 가지도록 하려면? 제네릭을 사용한 컴포넌트를 만들 수 있음

```
interface SelectProps<OptionType extends Record<string, string>> {
    options: OptionType;
    selectedOption?: keyof OptionType;
    onChange?: (selected?: keyof OptionType) => void;
}

const Select = <optionType extends Record<string, string>>({
options,
selectedOption,
onChange,
}: SelectProps<OptionTYpe>) => {
    // select component...
}
```
Select 컴폰너트에 전달되는 props의 타입 기반으로 타입이 추론되어 `<Select<추론된_타입>>` 형태의 컴포넌트가 생성된다. 이제 FruitSelect에서 잘못된 selectedOption을 전달하면 타입 에러가 발생한다.


### 8.2.7 HTMLAttributes, ReactProps 적용하기
리액트의 기본 props를 추가하려면 직접 타입을 지정해도 되지만 리액트에서 제공하는 타입을 사용하면 더 정확한 타입을 설정할 수 있다.
- ComponentPropsWithourRef - 리액트 컴포넌트의 prop 타입을 반환해주는 타입
- 


### 8.2.9 공변성과 반공변성
- 공변성: 타입이 더 구체적인 방향으로 확장될 때 허용되는 관계, 함수의 반환값 타입에서 주로 사용
- 반공변성: 반대로 타입이 더 일반적인 방향으로 확장될 때 허용, 함수의 매개변수 타입에서 주로 사용

