## React.FC

**기존**

- 암묵적으로 children 선언
- children을 사용을 선택적으로 가능

18v 이후

- 암묵적 children 선언 제거
    - children을 명시적으로 선언해줘야 함

## **PropsWithChildren**

- 표준적인 children 타입 선언 방법이지만 제네릭으로 복잡해 보임

```tsx
type PropsWithChildren<P = unknown> = P & { children?: ReactNode | undefined };
```

또한, 옵셔널로 children이 선언되어 있어 children이 없어도 에러가 발생하지 않음

⇒ ReactNode | undefined와 같음 

더 구체적으로 타이핑하고 싶다면 

```tsx
interface Props {
	children: ReactElement
}
```

와 같이 해야함

# ReactNode vs ReactElement vs JSX.Element


## React.ReactNode

- render함수가 반환할 수 있는 모든 형태

```tsx
type ReactNode =
	~~| ReactChild~~
	=>
	| ReactElement
  | string
  | number
  
  | ReactFragment
  | ReactPortal
  | boolean
  | null
  | undefined
```

## JSX.Element

```tsx
declare global {
  namespace JSX {
    interface Element extends React.ReactElement<any, any> {}
  }
}
```

**내부적으로** `ReactElement<any, any>`와 거의 동일

```tsx
interface Props {
	icon: JSX.Element;
}

const Item = ({ icon }: Props) => {
	// prop으로 받은 컴포넌트의 props에 접근할 수 있다
	const iconSize = icon.props.size;   // ❌ any로 추론

	return (‹li>{icon}</li>);
};
// icon prop에는 JSX.Element 타입을 가진 요소만 할당할 수 있다
const App = () => {
	return <Item icon=<icon size={14} />} />
};
```

icon.props.size는 **타입 추론 되지 않음**

React.ReactElemnet 로 추론관점에서 더 유용하게 활용 가능

## React.ReactElemnet

 React.createElement()로 만들어지는 리액트 요소 (JSX 하나)

```tsx
interface ItemProps {
icon: React.ReactElement<{ size: number }>;
}

const Item = ({ icon }: ItemProps) => {
const iconSize = icon.props.size; // ✅ number로 추론됨
return <li>{icon}</li>;
};

const App = () => <Item icon={<Icon size={14} />} />;
```

- size로 추론, 자동완성
- any가 아닌, number로 추론

# 리엑트에서 기본 HTML 요소 타입 활용 2가지 방법

## 1. DetailedHTMLProps

```tsx
type NativeButtonProps = React.DetailedHTMLProps<
  React.ButtonHTMLAttributes<HTMLButtonElement>,
  HTMLButtonElement
>;

type ButtonProps = {
  onClick?: NativeButtonProps["onClick"];
};
```

## 2. ComponentWithoutRef

ref를 활용해 생성된 DOM 노드에 접근 가능

### forwardRef

- ComponentProps<"button">
    - props + ref 전부 포함
    - 보통 **직접 DOM 태그를 쓰는 경우**라면 괜찮음
    - 일반 함수 컴포넌트에 쓰면 ref 타입이 남아서 혼동됨
- ComponentPropsWithoutRef<"button">
    - props만 포함, ref 제외
    - **일반 함수 컴포넌트 props 정의에 안전**
    - forwardRef와 함께 쓰면 ref는 forwardRef에서 따로 처리하므로 깔끔
 
# 타입스크립트로 리엑트 컴포넌트 만들기


# 공변성과 반공변성
```tsx
interface Props<T extends string> {
  onChangeA?: (selected: T) => void;
  onChangeB?(selected: T): void;
}

const Component = () => {
  const changeToPineApple = (selectedApple: "apple") => {
    console.log("this is pine" + selectedApple);
  };

  return (
    <Select
      // Error
      // onChangeA={changeToPineApple}
      // OK
      onChangeB={changeToPineApple}
    />
  );
};
```

```tsx
// 모든 유저(회원, 비회원)은 id를 갖고 있음
interface User {
  id: string;
}

interface Member extends User {
  nickName: string;
}

let users: Array<User> = [];
let members: Array<Member> = [];

users = members; // OK
members = users; // Error
```

일반적으로 타입들은 공변성을 가지고 있음

하지만 아래와 같이 제네릭 타입을 지닌 함수는 반공변성을 가진다.

```tsx
// 상황: 동물병원에서 진료 함수가 필요
type 강아지전문의 = (환자: 강아지) => void;
type 일반수의사 = (환자: 강아지 | 고양이) => void;

// 실제 함수들
const dogSpecialist: 강아지전문의 = (dog) => {
  console.log(`강아지 ${dog.name} 진료`);
  dog.bark(); // 강아지만의 메소드
};

const generalVet: 일반수의사 = (animal) => {
  console.log(`${animal.name} 건강검진`);
  // 강아지든 고양이든 공통으로 처리 가능
};

// 강아지 클리닉에서 의사를 배치한다면?
function 강아지클리닉운영(의사: 강아지전문의) {
  const 환자 = new 강아지("멍멍이");
  의사(환자); // 강아지만 옴
}
```

```tsx
type PrintUserInfo<U extends User> = (user: U) => void;

let printUser: PrintUserInfo<User> = (user) => console.log(user.id);

let printMember: PrintUserInfo<Member> = (user) => {
  console.log(user.id, user.nickName);
};

printMember = printUser; // OK.
printUser = printMember; // Error - Property 'nickName' is missing in type 'User' but required in type 'Member'.
```

다시 아래 예시를 보면 —strict 모드에서 A와 같이 화살표 표기법으로 작성하면 반공변성

```tsx
interface Props<T extends string> {
  onChangeA?: (selected: T) => void;
  onChangeB?(selected: T): void;
}
```

**함수 파라미터가 반공변성을 따르는 이유**:

- 함수는 **입력을 소비**하는 입장
- **더 넓은 타입을 처리할 수 있는 함수**가 **더 좁은 타입만 받는 자리**를 대신할 수 있음
