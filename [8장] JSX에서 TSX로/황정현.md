## React.FC

**기존**

- 암묵적으로 children 선언
- children을 사용을 선택적으로 가능

18v 이후

- 암묵적 children 선언 제거
    - children을 명시적으로 선언해줘야 함

## **PropsWithChildren**

- 표준적인 children 타입 선언 방법이지만 제네릭으로 복잡해 보임

```tsx
type PropsWithChildren<P = unknown> = P & { children?: ReactNode | undefined };
```

또한, 옵셔널로 children이 선언되어 있어 children이 없어도 에러가 발생하지 않음

⇒ ReactNode | undefined와 같음 

더 구체적으로 타이핑하고 싶다면 

```tsx
interface Props {
	children: ReactElement
}
```

와 같이 해야함

# ReactNode vs ReactElement vs JSX.Element


## React.ReactNode

- render함수가 반환할 수 있는 모든 형태

```tsx
type ReactNode =
	~~| ReactChild~~
	=>
	| ReactElement
  | string
  | number
  
  | ReactFragment
  | ReactPortal
  | boolean
  | null
  | undefined
```

## JSX.Element

```tsx
declare global {
  namespace JSX {
    interface Element extends React.ReactElement<any, any> {}
  }
}
```

**내부적으로** `ReactElement<any, any>`와 거의 동일

```tsx
interface Props {
	icon: JSX.Element;
}

const Item = ({ icon }: Props) => {
	// prop으로 받은 컴포넌트의 props에 접근할 수 있다
	const iconSize = icon.props.size;   // ❌ any로 추론

	return (‹li>{icon}</li>);
};
// icon prop에는 JSX.Element 타입을 가진 요소만 할당할 수 있다
const App = () => {
	return <Item icon=<icon size={14} />} />
};
```

icon.props.size는 **타입 추론 되지 않음**

React.ReactElemnet 로 추론관점에서 더 유용하게 활용 가능

## React.ReactElemnet

 React.createElement()로 만들어지는 리액트 요소 (JSX 하나)

```tsx
interface ItemProps {
icon: React.ReactElement<{ size: number }>;
}

const Item = ({ icon }: ItemProps) => {
const iconSize = icon.props.size; // ✅ number로 추론됨
return <li>{icon}</li>;
};

const App = () => <Item icon={<Icon size={14} />} />;
```

- size로 추론, 자동완성
- any가 아닌, number로 추론

# 리엑트에서 기본 HTML 요소 타입 활용 2가지 방법

## 1. DetailedHTMLProps

```tsx
type NativeButtonProps = React.DetailedHTMLProps<
  React.ButtonHTMLAttributes<HTMLButtonElement>,
  HTMLButtonElement
>;

type ButtonProps = {
  onClick?: NativeButtonProps["onClick"];
};
```

## 2. ComponentWithoutRef

ref를 활용해 생성된 DOM 노드에 접근 가능

### forwardRef

- ComponentProps<"button">
    - props + ref 전부 포함
    - 보통 **직접 DOM 태그를 쓰는 경우**라면 괜찮음
    - 일반 함수 컴포넌트에 쓰면 ref 타입이 남아서 혼동됨
- ComponentPropsWithoutRef<"button">
    - props만 포함, ref 제외
    - **일반 함수 컴포넌트 props 정의에 안전**
    - forwardRef와 함께 쓰면 ref는 forwardRef에서 따로 처리하므로 깔끔
 
# 타입스크립트로 리엑트 컴포넌트 만들기
