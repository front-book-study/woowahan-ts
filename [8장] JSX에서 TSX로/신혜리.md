## 8.1 ] 리액트 컴포넌트의 타입

---

### 1. 클래스 컴포넌트

```tsx
interface Component<P = {}, S = {}, SS = any>
  extends ComponentLifecycle<P, S, SS> {} // P는 Props, S는 State를 의미함.

class Component<P, S> {
  /* ... 생략 */
}

class PureComponent<P = {}, S = {}, SS = any> extends Component<P, S, SS> {}
```

### 2. 함수 컴포넌트

> React.FC = children props 허용
> React.VFC = children props 허용 X
> ⇒ children props 필요하지 않은 경우 React.VFC 더 많이 사용

```tsx
// 함수 선언을 사용한 방식
function Welcome(props: WelcomeProps): JSX.Element {}

// 함수 표현식을 사용한 방식 - React.FC 사용
const Welcome: React.FC<WelcomeProps> = ({ name }) => {};

// 함수 표현식을 사용한 방식 - React.VFC 사용 ➡️ React v18 이후 삭제됨.
const Welcome: React.VFC<WelcomeProps> = ({ name }) => {};
```

### 3. Children props 타입 지정

> children = React Element이 외에도 boolean, number 등 렌더링 할 수 있는 모든 타입 가능

```tsx
type PropsWithChildren<P> = P & { children?: ReactNode | undefined };
```

### 4. React.ReactElement vs JSX.Element vs React.ReactNode

> ReactNode > ReactElement > JSX.Element

```tsx
interface ReactElement<
  P = any,
  T extends string | JSXElementConstructor<any> =
    | string
    | JSXElementConstructor<any>,
> {
  type: T;
  props: P;
  key: Key | null;
}
```

```tsx
declare global {
  namespace JSX {
    interface Element extends React.ReactElement<any, any> {}
  }
}
```

```tsx
type ReactText = string | number;
type ReactChild = ReactElement | ReactText;
type ReactFragment = {} | Iterable<ReactNode>;

type ReactNode =
  | ReactChild
  | ReactFragment
  | ReactPortal
  | boolean
  | null
  | undefined;
```

### 5. ReactElement, ReactNode, JSX.Element 활용

> ReactElement : JSX의 createElement 메소드 호출로 생성된 리액트 엘리먼트를 나타내는 타입
> ReactNode : ReactElement 보다 좀 더 넓은 범위 . 리액트의 렌더 함수가 반환할 수 있는 모든 형태
> JSXElement : ReactElement의 특정 타입으로 props & 타입 필드를 any로 가지는 타입

### 6. 사용 예시

- ReactNode : children 타입

```tsx
interface MyComponentProps {
  children?: React.ReactNode;
  // ...
}
```

- JSX Element : 리액트 엘리먼트를 prop으로 전달 받아 render props 패턴으로 컴포넌트를 구현할 때 유용하게 활용

```tsx
interface Props {
  icon: JSX.Element;
}

const Item = ({ icon }: Props) => {
  const iconSize = icon.props.size;

  return <li>{icon}</li>;
};
```

- React Element : JSX.Element 대신에 ReactElement를 사용. 제네릭에 직접 해당 컴포넌트의 props 타입을 명시.

```tsx
interface IconProps {
  size: number;
}

interface Props {
  icon: React.ReactElement<IconProps>;
}

const Item = ({ icon }: Props) => {
  const iconSize = icon.props.size;

  return <li>{icon}</li>;
};
```

### 7. 리액트에서 기본 HTML 요소 타입 활용

- `DetailedHTMLProps` : 특정 HTML 요소의 모든 속성(기본 HTML 속성 및 React 추가 속성)을 포함하는 타입을 정의하는 데 사용됨. HTML 요소의 타입 안전성을 보장.
- `ComponentPropsWithoutRef` : `ref` 속성을 포함하지 않는 컴포넌트의 타입을 정의할 때 사용됨. 주로 `forwardRef`를 사용하지 않는 컴포넌트에 적합.

## 8.2 ] 타입스크립트로 리액트 컴포넌트 만들기

---

### 1. JSX로 구현된 Select 컴포넌트

```tsx
const Select = ({ onChange, options, selectedOption }) => {
  const handleChange = e => {
    const selected = Object.entries(options).find(
      ([_, value]) => value === e.target.value,
    )?.[0];
    onChange?.(selected);
  };

  return (
    <select
      onChange={handleChange}
      value={selectedOption && options[selectedOption]}
    >
      {Object.entries(options).map(([key, value]) => (
        <option key={key} value={value}>
          {value}
        </option>
      ))}
    </select>
  );
};
```

### 2. JSDocs로 일부 타입 지정하기

> 컴포넌트의 속성 타입을 명시하기 위해 JSDocs를 사용

```tsx
/**
* Select 컴포넌트
* @param {Object} props - Select 컴포넌트로 넘겨주는 속성
* @param {Object} props.options - { [key: string]: string } 형식으로 이루어진 option 객체
* @param {string | undefined} props.selectedOption - 현재 선택된 option의 key값 (optional)
* @param {function} props.onChange - select 값이 변경되었을 때 불리는 callBack 함수 (optional)
* @returns {JSX.Element}
*/
const Select = //...

```
